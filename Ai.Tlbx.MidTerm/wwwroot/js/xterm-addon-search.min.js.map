{"version":3,"file":"xterm-addon-search.min.js","mappings":"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","sources":["webpack://SearchAddon/webpack/universalModuleDefinition","webpack://SearchAddon/./src/DecorationManager.ts","webpack://SearchAddon/./src/SearchEngine.ts","webpack://SearchAddon/./src/SearchLineCache.ts","webpack://SearchAddon/./src/SearchResultTracker.ts","webpack://SearchAddon/./src/SearchState.ts","webpack://SearchAddon/../../out/vs/base/common/arrays.js","webpack://SearchAddon/../../out/vs/base/common/arraysFind.js","webpack://SearchAddon/../../out/vs/base/common/async.js","webpack://SearchAddon/../../out/vs/base/common/cancellation.js","webpack://SearchAddon/../../out/vs/base/common/collections.js","webpack://SearchAddon/../../out/vs/base/common/errors.js","webpack://SearchAddon/../../out/vs/base/common/event.js","webpack://SearchAddon/../../out/vs/base/common/functional.js","webpack://SearchAddon/../../out/vs/base/common/iterator.js","webpack://SearchAddon/../../out/vs/base/common/lazy.js","webpack://SearchAddon/../../out/vs/base/common/lifecycle.js","webpack://SearchAddon/../../out/vs/base/common/linkedList.js","webpack://SearchAddon/../../out/vs/base/common/map.js","webpack://SearchAddon/../../out/vs/base/common/platform.js","webpack://SearchAddon/../../out/vs/base/common/stopwatch.js","webpack://SearchAddon/../../out/vs/base/common/symbols.js","webpack://SearchAddon/webpack/bootstrap","webpack://SearchAddon/./src/SearchAddon.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SearchAddon\"] = factory();\n\telse\n\t\troot[\"SearchAddon\"] = factory();\n})(globalThis, () => {\nreturn ","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport type { Terminal, IDisposable, IDecoration } from '@xterm/xterm';\nimport type { ISearchDecorationOptions } from '@xterm/addon-search';\nimport { dispose, Disposable, toDisposable } from 'vs/base/common/lifecycle';\nimport type { ISearchResult } from './SearchEngine';\n\n/**\n * Interface for managing a highlight decoration.\n */\ninterface IHighlight extends IDisposable {\n  decoration: IDecoration;\n  match: ISearchResult;\n}\n\n/**\n * Interface for managing multiple decorations for a single match.\n */\ninterface IMultiHighlight extends IDisposable {\n  decorations: IDecoration[];\n  match: ISearchResult;\n}\n\n/**\n * Manages visual decorations for search results including highlighting and active selection\n * indicators. This class handles the creation, styling, and disposal of search-related decorations.\n */\nexport class DecorationManager extends Disposable {\n  private _highlightDecorations: IHighlight[] = [];\n  private _highlightedLines: Set<number> = new Set();\n\n  constructor(private readonly _terminal: Terminal) {\n    super();\n    this._register(toDisposable(() => this.clearHighlightDecorations()));\n  }\n\n  /**\n   * Creates decorations for all provided search results.\n   * @param results The search results to create decorations for.\n   * @param options The decoration options.\n   */\n  public createHighlightDecorations(results: ISearchResult[], options: ISearchDecorationOptions): void {\n    this.clearHighlightDecorations();\n\n    for (const match of results) {\n      const decorations = this._createResultDecorations(match, options, false);\n      if (decorations) {\n        for (const decoration of decorations) {\n          this._storeDecoration(decoration, match);\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates decorations for the currently active search result.\n   * @param result The active search result.\n   * @param options The decoration options.\n   * @returns The multi-highlight decoration or undefined if creation failed.\n   */\n  public createActiveDecoration(result: ISearchResult, options: ISearchDecorationOptions): IMultiHighlight | undefined {\n    const decorations = this._createResultDecorations(result, options, true);\n    if (decorations) {\n      return { decorations, match: result, dispose() { dispose(decorations); } };\n    }\n    return undefined;\n  }\n\n  /**\n   * Clears all highlight decorations.\n   */\n  public clearHighlightDecorations(): void {\n    dispose(this._highlightDecorations);\n    this._highlightDecorations = [];\n    this._highlightedLines.clear();\n  }\n\n  /**\n   * Stores a decoration and tracks it for management.\n   * @param decoration The decoration to store.\n   * @param match The search result this decoration represents.\n   */\n  private _storeDecoration(decoration: IDecoration, match: ISearchResult): void {\n    this._highlightedLines.add(decoration.marker.line);\n    this._highlightDecorations.push({ decoration, match, dispose() { decoration.dispose(); } });\n  }\n\n  /**\n   * Applies styles to the decoration when it is rendered.\n   * @param element The decoration's element.\n   * @param borderColor The border color to apply.\n   * @param isActiveResult Whether the element is part of the active search result.\n   */\n  private _applyStyles(element: HTMLElement, borderColor: string | undefined, isActiveResult: boolean): void {\n    if (!element.classList.contains('xterm-find-result-decoration')) {\n      element.classList.add('xterm-find-result-decoration');\n      if (borderColor) {\n        element.style.outline = `1px solid ${borderColor}`;\n      }\n    }\n    if (isActiveResult) {\n      element.classList.add('xterm-find-active-result-decoration');\n    }\n  }\n\n  /**\n   * Creates a decoration for the result and applies styles\n   * @param result the search result for which to create the decoration\n   * @param options the options for the decoration\n   * @param isActiveResult whether this is the currently active result\n   * @returns the decorations or undefined if the marker has already been disposed of\n   */\n  private _createResultDecorations(result: ISearchResult, options: ISearchDecorationOptions, isActiveResult: boolean): IDecoration[] | undefined {\n    // Gather decoration ranges for this match as it could wrap\n    const decorationRanges: [number, number, number][] = [];\n    let currentCol = result.col;\n    let remainingSize = result.size;\n    let markerOffset = -this._terminal.buffer.active.baseY - this._terminal.buffer.active.cursorY + result.row;\n    while (remainingSize > 0) {\n      const amountThisRow = Math.min(this._terminal.cols - currentCol, remainingSize);\n      decorationRanges.push([markerOffset, currentCol, amountThisRow]);\n      currentCol = 0;\n      remainingSize -= amountThisRow;\n      markerOffset++;\n    }\n\n    // Create the decorations\n    const decorations: IDecoration[] = [];\n    for (const range of decorationRanges) {\n      const marker = this._terminal.registerMarker(range[0]);\n      const decoration = this._terminal.registerDecoration({\n        marker,\n        x: range[1],\n        width: range[2],\n        backgroundColor: isActiveResult ? options.activeMatchBackground : options.matchBackground,\n        overviewRulerOptions: this._highlightedLines.has(marker.line) ? undefined : {\n          color: isActiveResult ? options.activeMatchColorOverviewRuler : options.matchOverviewRuler,\n          position: 'center'\n        }\n      });\n      if (decoration) {\n        const disposables: IDisposable[] = [];\n        disposables.push(marker);\n        disposables.push(decoration.onRender((e) => this._applyStyles(e, isActiveResult ? options.activeMatchBorder : options.matchBorder, false)));\n        disposables.push(decoration.onDispose(() => dispose(disposables)));\n        decorations.push(decoration);\n      }\n    }\n\n    return decorations.length === 0 ? undefined : decorations;\n  }\n}\n\n\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport type { Terminal } from '@xterm/xterm';\nimport type { ISearchOptions } from '@xterm/addon-search';\nimport type { SearchLineCache } from './SearchLineCache';\n\n/**\n * Represents the position to start a search from.\n */\ninterface ISearchPosition {\n  startCol: number;\n  startRow: number;\n}\n\n/**\n * Represents a search result with its position and content.\n */\nexport interface ISearchResult {\n  term: string;\n  col: number;\n  row: number;\n  size: number;\n}\n\n/**\n * Configuration constants for the search engine functionality.\n */\nconst enum Constants {\n  /**\n   * Characters that are considered non-word characters for search boundary detection. These\n   * characters are used to determine word boundaries when performing whole-word searches. Includes\n   * common punctuation, symbols, and whitespace characters.\n   */\n  NON_WORD_CHARACTERS = ' ~!@#$%^&*()+`-=[]{}|\\\\;:\"\\',./<>?'\n}\n\n/**\n * Core search engine that handles finding text within terminal content.\n * This class is responsible for the actual search algorithms and position calculations.\n */\nexport class SearchEngine {\n  constructor(\n    private readonly _terminal: Terminal,\n    private readonly _lineCache: SearchLineCache\n  ) {}\n\n  /**\n   * Find the first occurrence of a term starting from a specific position.\n   * @param term The search term.\n   * @param startRow The row to start searching from.\n   * @param startCol The column to start searching from.\n   * @param searchOptions Search options.\n   * @returns The search result if found, undefined otherwise.\n   */\n  public find(term: string, startRow: number, startCol: number, searchOptions?: ISearchOptions): ISearchResult | undefined {\n    if (!term || term.length === 0) {\n      this._terminal.clearSelection();\n      return undefined;\n    }\n    if (startCol > this._terminal.cols) {\n      throw new Error(`Invalid col: ${startCol} to search in terminal of ${this._terminal.cols} cols`);\n    }\n\n    this._lineCache.initLinesCache();\n\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    // Search startRow\n    let result = this._findInLine(term, searchPosition, searchOptions);\n    // Search from startRow + 1 to end\n    if (!result) {\n      for (let y = startRow + 1; y < this._terminal.buffer.active.baseY + this._terminal.rows; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Find the next occurrence of a term with wrapping and selection management.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @param cachedSearchTerm The cached search term to determine incremental behavior.\n   * @returns The search result if found, undefined otherwise.\n   */\n  public findNextWithSelection(term: string, searchOptions?: ISearchOptions, cachedSearchTerm?: string): ISearchResult | undefined {\n    if (!term || term.length === 0) {\n      this._terminal.clearSelection();\n      return undefined;\n    }\n\n    const prevSelectedPos = this._terminal.getSelectionPosition();\n    this._terminal.clearSelection();\n\n    let startCol = 0;\n    let startRow = 0;\n    if (prevSelectedPos) {\n      if (cachedSearchTerm === term) {\n        startCol = prevSelectedPos.end.x;\n        startRow = prevSelectedPos.end.y;\n      } else {\n        startCol = prevSelectedPos.start.x;\n        startRow = prevSelectedPos.start.y;\n      }\n    }\n\n    this._lineCache.initLinesCache();\n\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    // Search startRow\n    let result = this._findInLine(term, searchPosition, searchOptions);\n    // Search from startRow + 1 to end\n    if (!result) {\n      for (let y = startRow + 1; y < this._terminal.buffer.active.baseY + this._terminal.rows; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n    // If we hit the bottom and didn't search from the very top wrap back up\n    if (!result && startRow !== 0) {\n      for (let y = 0; y < startRow; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // If there is only one result, wrap back and return selection if it exists.\n    if (!result && prevSelectedPos) {\n      searchPosition.startRow = prevSelectedPos.start.y;\n      searchPosition.startCol = 0;\n      result = this._findInLine(term, searchPosition, searchOptions);\n    }\n\n    return result;\n  }\n\n  /**\n   * Find the previous occurrence of a term with wrapping and selection management.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @param cachedSearchTerm The cached search term to determine if expansion should occur.\n   * @returns The search result if found, undefined otherwise.\n   */\n  public findPreviousWithSelection(term: string, searchOptions?: ISearchOptions, cachedSearchTerm?: string): ISearchResult | undefined {\n    if (!term || term.length === 0) {\n      this._terminal.clearSelection();\n      return undefined;\n    }\n\n    const prevSelectedPos = this._terminal.getSelectionPosition();\n    this._terminal.clearSelection();\n\n    let startRow = this._terminal.buffer.active.baseY + this._terminal.rows - 1;\n    let startCol = this._terminal.cols;\n    const isReverseSearch = true;\n\n    this._lineCache.initLinesCache();\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    let result: ISearchResult | undefined;\n    if (prevSelectedPos) {\n      searchPosition.startRow = startRow = prevSelectedPos.start.y;\n      searchPosition.startCol = startCol = prevSelectedPos.start.x;\n      if (cachedSearchTerm !== term) {\n        // Try to expand selection to right first.\n        result = this._findInLine(term, searchPosition, searchOptions, false);\n        if (!result) {\n          // If selection was not able to be expanded to the right, then try reverse search\n          searchPosition.startRow = startRow = prevSelectedPos.end.y;\n          searchPosition.startCol = startCol = prevSelectedPos.end.x;\n        }\n      }\n    }\n\n    if (!result) {\n      result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n    }\n\n    // Search from startRow - 1 to top\n    if (!result) {\n      searchPosition.startCol = Math.max(searchPosition.startCol, this._terminal.cols);\n      for (let y = startRow - 1; y >= 0; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n    // If we hit the top and didn't search from the very bottom wrap back down\n    if (!result && startRow !== (this._terminal.buffer.active.baseY + this._terminal.rows - 1)) {\n      for (let y = (this._terminal.buffer.active.baseY + this._terminal.rows - 1); y >= startRow; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * A found substring is a whole word if it doesn't have an alphanumeric character directly\n   * adjacent to it.\n   * @param searchIndex starting index of the potential whole word substring\n   * @param line entire string in which the potential whole word was found\n   * @param term the substring that starts at searchIndex\n   */\n  private _isWholeWord(searchIndex: number, line: string, term: string): boolean {\n    return ((searchIndex === 0) || (Constants.NON_WORD_CHARACTERS.includes(line[searchIndex - 1]))) &&\n      (((searchIndex + term.length) === line.length) || (Constants.NON_WORD_CHARACTERS.includes(line[searchIndex + term.length])));\n  }\n\n  /**\n   * Searches a line for a search term. Takes the provided terminal line and searches the text line,\n   * which may contain subsequent terminal lines if the text is wrapped. If the provided line number\n   * is part of a wrapped text line that started on an earlier line then it is skipped since it will\n   * be properly searched when the terminal line that the text starts on is searched.\n   * @param term The search term.\n   * @param searchPosition The position to start the search.\n   * @param searchOptions Search options.\n   * @param isReverseSearch Whether the search should start from the right side of the terminal and\n   * search to the left.\n   * @returns The search result if it was found.\n   */\n  private _findInLine(term: string, searchPosition: ISearchPosition, searchOptions: ISearchOptions = {}, isReverseSearch: boolean = false): ISearchResult | undefined {\n    const row = searchPosition.startRow;\n    const col = searchPosition.startCol;\n\n    // Ignore wrapped lines, only consider on unwrapped line (first row of command string).\n    const firstLine = this._terminal.buffer.active.getLine(row);\n    if (firstLine?.isWrapped) {\n      if (isReverseSearch) {\n        searchPosition.startCol += this._terminal.cols;\n        return;\n      }\n\n      // This will iterate until we find the line start.\n      // When we find it, we will search using the calculated start column.\n      searchPosition.startRow--;\n      searchPosition.startCol += this._terminal.cols;\n      return this._findInLine(term, searchPosition, searchOptions);\n    }\n    let cache = this._lineCache.getLineFromCache(row);\n    if (!cache) {\n      cache = this._lineCache.translateBufferLineToStringWithWrap(row, true);\n      this._lineCache.setLineInCache(row, cache);\n    }\n    const [stringLine, offsets] = cache;\n\n    const offset = this._bufferColsToStringOffset(row, col);\n    let searchTerm = term;\n    let searchStringLine = stringLine;\n    if (!searchOptions.regex) {\n      searchTerm = searchOptions.caseSensitive ? term : term.toLowerCase();\n      searchStringLine = searchOptions.caseSensitive ? stringLine : stringLine.toLowerCase();\n    }\n\n    let resultIndex = -1;\n    if (searchOptions.regex) {\n      const searchRegex = RegExp(searchTerm, searchOptions.caseSensitive ? 'g' : 'gi');\n      let foundTerm: RegExpExecArray | null;\n      if (isReverseSearch) {\n        // This loop will get the resultIndex of the _last_ regex match in the range 0..offset\n        while (foundTerm = searchRegex.exec(searchStringLine.slice(0, offset))) {\n          resultIndex = searchRegex.lastIndex - foundTerm[0].length;\n          term = foundTerm[0];\n          searchRegex.lastIndex -= (term.length - 1);\n        }\n      } else {\n        foundTerm = searchRegex.exec(searchStringLine.slice(offset));\n        if (foundTerm && foundTerm[0].length > 0) {\n          resultIndex = offset + (searchRegex.lastIndex - foundTerm[0].length);\n          term = foundTerm[0];\n        }\n      }\n    } else {\n      if (isReverseSearch) {\n        if (offset - searchTerm.length >= 0) {\n          resultIndex = searchStringLine.lastIndexOf(searchTerm, offset - searchTerm.length);\n        }\n      } else {\n        resultIndex = searchStringLine.indexOf(searchTerm, offset);\n      }\n    }\n\n    if (resultIndex >= 0) {\n      if (searchOptions.wholeWord && !this._isWholeWord(resultIndex, searchStringLine, term)) {\n        return;\n      }\n\n      // Adjust the row number and search index if needed since a \"line\" of text can span multiple\n      // rows\n      let startRowOffset = 0;\n      while (startRowOffset < offsets.length - 1 && resultIndex >= offsets[startRowOffset + 1]) {\n        startRowOffset++;\n      }\n      let endRowOffset = startRowOffset;\n      while (endRowOffset < offsets.length - 1 && resultIndex + term.length >= offsets[endRowOffset + 1]) {\n        endRowOffset++;\n      }\n      const startColOffset = resultIndex - offsets[startRowOffset];\n      const endColOffset = resultIndex + term.length - offsets[endRowOffset];\n      const startColIndex = this._stringLengthToBufferSize(row + startRowOffset, startColOffset);\n      const endColIndex = this._stringLengthToBufferSize(row + endRowOffset, endColOffset);\n      const size = endColIndex - startColIndex + this._terminal.cols * (endRowOffset - startRowOffset);\n\n      return {\n        term,\n        col: startColIndex,\n        row: row + startRowOffset,\n        size\n      };\n    }\n  }\n\n  private _stringLengthToBufferSize(row: number, offset: number): number {\n    const line = this._terminal.buffer.active.getLine(row);\n    if (!line) {\n      return 0;\n    }\n    for (let i = 0; i < offset; i++) {\n      const cell = line.getCell(i);\n      if (!cell) {\n        break;\n      }\n      // Adjust the searchIndex to normalize emoji into single chars\n      const char = cell.getChars();\n      if (char.length > 1) {\n        offset -= char.length - 1;\n      }\n      // Adjust the searchIndex for empty characters following wide unicode\n      // chars (eg. CJK)\n      const nextCell = line.getCell(i + 1);\n      if (nextCell && nextCell.getWidth() === 0) {\n        offset++;\n      }\n    }\n    return offset;\n  }\n\n  private _bufferColsToStringOffset(startRow: number, cols: number): number {\n    let lineIndex = startRow;\n    let offset = 0;\n    let line = this._terminal.buffer.active.getLine(lineIndex);\n    while (cols > 0 && line) {\n      for (let i = 0; i < cols && i < this._terminal.cols; i++) {\n        const cell = line.getCell(i);\n        if (!cell) {\n          break;\n        }\n        if (cell.getWidth()) {\n          // Treat null characters as whitespace to align with the translateToString API\n          offset += cell.getCode() === 0 ? 1 : cell.getChars().length;\n        }\n      }\n      lineIndex++;\n      line = this._terminal.buffer.active.getLine(lineIndex);\n      if (line && !line.isWrapped) {\n        break;\n      }\n      cols -= this._terminal.cols;\n    }\n    return offset;\n  }\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport type { Terminal } from '@xterm/xterm';\nimport { combinedDisposable, Disposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { disposableTimeout } from 'vs/base/common/async';\n\nexport type LineCacheEntry = [\n  /**\n   * The string representation of a line (as opposed to the buffer cell representation).\n   */\n  lineAsString: string,\n  /**\n   * The offsets where each line starts when the entry describes a wrapped line.\n   */\n  lineOffsets: number[]\n];\n\n/**\n * Configuration constants for the search line cache functionality.\n */\nconst enum Constants {\n  /**\n   * Time-to-live for cached search results in milliseconds. After this duration, cached search\n   * results will be invalidated to ensure they remain consistent with terminal content changes.\n   */\n  LINES_CACHE_TIME_TO_LIVE = 15000\n}\n\nexport class SearchLineCache extends Disposable {\n  /**\n   * translateBufferLineToStringWithWrap is a fairly expensive call.\n   * We memoize the calls into an array that has a time based ttl.\n   * _linesCache is also invalidated when the terminal cursor moves.\n   */\n  private _linesCache: LineCacheEntry[] | undefined;\n  private _linesCacheTimeout = this._register(new MutableDisposable());\n  private _linesCacheDisposables = this._register(new MutableDisposable());\n\n  constructor(private readonly _terminal: Terminal) {\n    super();\n    this._register(toDisposable(() => this._destroyLinesCache()));\n  }\n\n  /**\n   * Sets up a line cache with a ttl\n   */\n  public initLinesCache(): void {\n    if (!this._linesCache) {\n      this._linesCache = new Array(this._terminal.buffer.active.length);\n      this._linesCacheDisposables.value = combinedDisposable(\n        this._terminal.onLineFeed(() => this._destroyLinesCache()),\n        this._terminal.onCursorMove(() => this._destroyLinesCache()),\n        this._terminal.onResize(() => this._destroyLinesCache())\n      );\n    }\n\n    this._linesCacheTimeout.value = disposableTimeout(() => this._destroyLinesCache(), Constants.LINES_CACHE_TIME_TO_LIVE);\n  }\n\n  private _destroyLinesCache(): void {\n    this._linesCache = undefined;\n    this._linesCacheDisposables.clear();\n    this._linesCacheTimeout.clear();\n  }\n\n  public getLineFromCache(row: number): LineCacheEntry | undefined {\n    return this._linesCache?.[row];\n  }\n\n  public setLineInCache(row: number, entry: LineCacheEntry): void {\n    if (this._linesCache) {\n      this._linesCache[row] = entry;\n    }\n  }\n\n  /**\n   * Translates a buffer line to a string, including subsequent lines if they are wraps.\n   * Wide characters will count as two columns in the resulting string. This\n   * function is useful for getting the actual text underneath the raw selection\n   * position.\n   * @param lineIndex The index of the line being translated.\n   * @param trimRight Whether to trim whitespace to the right.\n   */\n  public translateBufferLineToStringWithWrap(lineIndex: number, trimRight: boolean): LineCacheEntry {\n    const strings = [];\n    const lineOffsets = [0];\n    let line = this._terminal.buffer.active.getLine(lineIndex);\n    while (line) {\n      const nextLine = this._terminal.buffer.active.getLine(lineIndex + 1);\n      const lineWrapsToNext = nextLine ? nextLine.isWrapped : false;\n      let string = line.translateToString(!lineWrapsToNext && trimRight);\n      if (lineWrapsToNext && nextLine) {\n        const lastCell = line.getCell(line.length - 1);\n        const lastCellIsNull = lastCell && lastCell.getCode() === 0 && lastCell.getWidth() === 1;\n        // a wide character wrapped to the next line\n        if (lastCellIsNull && nextLine.getCell(0)?.getWidth() === 2) {\n          string = string.slice(0, -1);\n        }\n      }\n      strings.push(string);\n      if (lineWrapsToNext) {\n        lineOffsets.push(lineOffsets[lineOffsets.length - 1] + string.length);\n      } else {\n        break;\n      }\n      lineIndex++;\n      line = nextLine;\n    }\n    return [strings.join(''), lineOffsets];\n  }\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport type { ISearchResultChangeEvent } from '@xterm/addon-search';\nimport type { IDisposable } from '@xterm/xterm';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport type { ISearchResult } from './SearchEngine';\n\n/**\n * Interface for managing a currently selected decoration.\n */\ninterface ISelectedDecoration extends IDisposable {\n  match: ISearchResult;\n}\n\n/**\n * Tracks search results, manages result indexing, and fires events when results change.\n * This class provides centralized management of search result state and notifications.\n */\nexport class SearchResultTracker extends Disposable {\n  private _searchResults: ISearchResult[] = [];\n  private _selectedDecoration: ISelectedDecoration | undefined;\n\n  private readonly _onDidChangeResults = this._register(new Emitter<ISearchResultChangeEvent>());\n  public get onDidChangeResults(): Event<ISearchResultChangeEvent> { return this._onDidChangeResults.event; }\n\n  /**\n   * Gets the current search results.\n   */\n  public get searchResults(): ReadonlyArray<ISearchResult> {\n    return this._searchResults;\n  }\n\n  /**\n   * Gets the currently selected decoration.\n   */\n  public get selectedDecoration(): ISelectedDecoration | undefined {\n    return this._selectedDecoration;\n  }\n\n  /**\n   * Sets the currently selected decoration.\n   */\n  public set selectedDecoration(decoration: ISelectedDecoration | undefined) {\n    this._selectedDecoration = decoration;\n  }\n\n  /**\n   * Updates the search results with a new set of results.\n   * @param results The new search results.\n   * @param maxResults The maximum number of results to track.\n   */\n  public updateResults(results: ISearchResult[], maxResults: number): void {\n    this._searchResults = results.slice(0, maxResults);\n  }\n\n  /**\n   * Clears all search results.\n   */\n  public clearResults(): void {\n    this._searchResults = [];\n  }\n\n  /**\n   * Clears the selected decoration.\n   */\n  public clearSelectedDecoration(): void {\n    if (this._selectedDecoration) {\n      this._selectedDecoration.dispose();\n      this._selectedDecoration = undefined;\n    }\n  }\n\n  /**\n   * Finds the index of a result in the current results array.\n   * @param result The result to find.\n   * @returns The index of the result, or -1 if not found.\n   */\n  public findResultIndex(result: ISearchResult): number {\n    for (let i = 0; i < this._searchResults.length; i++) {\n      const match = this._searchResults[i];\n      if (match.row === result.row && match.col === result.col && match.size === result.size) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Fires a result change event with the current state.\n   * @param hasDecorations Whether decorations are enabled.\n   */\n  public fireResultsChanged(hasDecorations: boolean): void {\n    if (!hasDecorations) {\n      return;\n    }\n\n    let resultIndex = -1;\n    if (this._selectedDecoration) {\n      resultIndex = this.findResultIndex(this._selectedDecoration.match);\n    }\n\n    this._onDidChangeResults.fire({\n      resultIndex,\n      resultCount: this._searchResults.length\n    });\n  }\n\n  /**\n   * Resets all state.\n   */\n  public reset(): void {\n    this.clearSelectedDecoration();\n    this.clearResults();\n  }\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport type { ISearchOptions } from '@xterm/addon-search';\n\n/**\n * Manages search state including cached search terms, options tracking, and validation.\n * This class provides a centralized way to handle search state consistency and option changes.\n */\nexport class SearchState {\n  private _cachedSearchTerm: string | undefined;\n  private _lastSearchOptions: ISearchOptions | undefined;\n\n  /**\n   * Gets the currently cached search term.\n   */\n  public get cachedSearchTerm(): string | undefined {\n    return this._cachedSearchTerm;\n  }\n\n  /**\n   * Sets the cached search term.\n   */\n  public set cachedSearchTerm(term: string | undefined) {\n    this._cachedSearchTerm = term;\n  }\n\n  /**\n   * Gets the last search options used.\n   */\n  public get lastSearchOptions(): ISearchOptions | undefined {\n    return this._lastSearchOptions;\n  }\n\n  /**\n   * Sets the last search options used.\n   */\n  public set lastSearchOptions(options: ISearchOptions | undefined) {\n    this._lastSearchOptions = options;\n  }\n\n  /**\n   * Validates a search term to ensure it's not empty or invalid.\n   * @param term The search term to validate.\n   * @returns true if the term is valid for searching.\n   */\n  public isValidSearchTerm(term: string): boolean {\n    return !!(term && term.length > 0);\n  }\n\n  /**\n   * Determines if search options have changed compared to the last search.\n   * @param newOptions The new search options to compare.\n   * @returns true if the options have changed.\n   */\n  public didOptionsChange(newOptions?: ISearchOptions): boolean {\n    if (!this._lastSearchOptions) {\n      return true;\n    }\n    if (!newOptions) {\n      return false;\n    }\n    if (this._lastSearchOptions.caseSensitive !== newOptions.caseSensitive) {\n      return true;\n    }\n    if (this._lastSearchOptions.regex !== newOptions.regex) {\n      return true;\n    }\n    if (this._lastSearchOptions.wholeWord !== newOptions.wholeWord) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Determines if a new search should trigger highlighting updates.\n   * @param term The search term.\n   * @param options The search options.\n   * @returns true if highlighting should be updated.\n   */\n  public shouldUpdateHighlighting(term: string, options?: ISearchOptions): boolean {\n    if (!options?.decorations) {\n      return false;\n    }\n    return this._cachedSearchTerm === undefined ||\n           term !== this._cachedSearchTerm ||\n           this.didOptionsChange(options);\n  }\n\n  /**\n   * Clears the cached search term.\n   */\n  public clearCachedTerm(): void {\n    this._cachedSearchTerm = undefined;\n  }\n\n  /**\n   * Resets all state.\n   */\n  public reset(): void {\n    this._cachedSearchTerm = undefined;\n    this._lastSearchOptions = undefined;\n  }\n}\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Permutation = exports.CallbackIterable = exports.ArrayQueue = exports.booleanComparator = exports.numberComparator = exports.CompareResult = void 0;\nexports.tail = tail;\nexports.tail2 = tail2;\nexports.equals = equals;\nexports.removeFastWithoutKeepingOrder = removeFastWithoutKeepingOrder;\nexports.binarySearch = binarySearch;\nexports.binarySearch2 = binarySearch2;\nexports.quickSelect = quickSelect;\nexports.groupBy = groupBy;\nexports.groupAdjacentBy = groupAdjacentBy;\nexports.forEachAdjacent = forEachAdjacent;\nexports.forEachWithNeighbors = forEachWithNeighbors;\nexports.sortedDiff = sortedDiff;\nexports.delta = delta;\nexports.top = top;\nexports.topAsync = topAsync;\nexports.coalesce = coalesce;\nexports.coalesceInPlace = coalesceInPlace;\nexports.move = move;\nexports.isFalsyOrEmpty = isFalsyOrEmpty;\nexports.isNonEmptyArray = isNonEmptyArray;\nexports.distinct = distinct;\nexports.uniqueFilter = uniqueFilter;\nexports.firstOrDefault = firstOrDefault;\nexports.lastOrDefault = lastOrDefault;\nexports.commonPrefixLength = commonPrefixLength;\nexports.range = range;\nexports.index = index;\nexports.insert = insert;\nexports.remove = remove;\nexports.arrayInsert = arrayInsert;\nexports.shuffle = shuffle;\nexports.pushToStart = pushToStart;\nexports.pushToEnd = pushToEnd;\nexports.pushMany = pushMany;\nexports.mapArrayOrNot = mapArrayOrNot;\nexports.asArray = asArray;\nexports.getRandomElement = getRandomElement;\nexports.insertInto = insertInto;\nexports.splice = splice;\nexports.compareBy = compareBy;\nexports.tieBreakComparators = tieBreakComparators;\nexports.reverseOrder = reverseOrder;\nconst errors_1 = require(\"vs/base/common/errors\");\nconst arraysFind_1 = require(\"./arraysFind\");\n/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nfunction tail(array, n = 0) {\n    return array[array.length - (1 + n)];\n}\nfunction tail2(arr) {\n    if (arr.length === 0) {\n        throw new Error('Invalid tail call');\n    }\n    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\nfunction equals(one, other, itemEquals = (a, b) => a === b) {\n    if (one === other) {\n        return true;\n    }\n    if (!one || !other) {\n        return false;\n    }\n    if (one.length !== other.length) {\n        return false;\n    }\n    for (let i = 0, len = one.length; i < len; i++) {\n        if (!itemEquals(one[i], other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\n * but changes the order of the array\n */\nfunction removeFastWithoutKeepingOrder(array, index) {\n    const last = array.length - 1;\n    if (index < last) {\n        array[index] = array[last];\n    }\n    array.pop();\n}\n/**\n * Performs a binary search algorithm over a sorted array.\n *\n * @param array The array being searched.\n * @param key The value we search for.\n * @param comparator A function that takes two array elements and returns zero\n *   if they are equal, a negative number if the first element precedes the\n *   second one in the sorting order, or a positive number if the second element\n *   precedes the first one.\n * @return See {@link binarySearch2}\n */\nfunction binarySearch(array, key, comparator) {\n    return binarySearch2(array.length, i => comparator(array[i], key));\n}\n/**\n * Performs a binary search algorithm over a sorted collection. Useful for cases\n * when we need to perform a binary search over something that isn't actually an\n * array, and converting data to an array would defeat the use of binary search\n * in the first place.\n *\n * @param length The collection length.\n * @param compareToKey A function that takes an index of an element in the\n *   collection and returns zero if the value at this index is equal to the\n *   search key, a negative number if the value precedes the search key in the\n *   sorting order, or a positive number if the search key precedes the value.\n * @return A non-negative index of an element, if found. If not found, the\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\n *   where the key should be inserted to maintain the sorting order.\n */\nfunction binarySearch2(length, compareToKey) {\n    let low = 0, high = length - 1;\n    while (low <= high) {\n        const mid = ((low + high) / 2) | 0;\n        const comp = compareToKey(mid);\n        if (comp < 0) {\n            low = mid + 1;\n        }\n        else if (comp > 0) {\n            high = mid - 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return -(low + 1);\n}\nfunction quickSelect(nth, data, compare) {\n    nth = nth | 0;\n    if (nth >= data.length) {\n        throw new TypeError('invalid index');\n    }\n    const pivotValue = data[Math.floor(data.length * Math.random())];\n    const lower = [];\n    const higher = [];\n    const pivots = [];\n    for (const value of data) {\n        const val = compare(value, pivotValue);\n        if (val < 0) {\n            lower.push(value);\n        }\n        else if (val > 0) {\n            higher.push(value);\n        }\n        else {\n            pivots.push(value);\n        }\n    }\n    if (nth < lower.length) {\n        return quickSelect(nth, lower, compare);\n    }\n    else if (nth < lower.length + pivots.length) {\n        return pivots[0];\n    }\n    else {\n        return quickSelect(nth - (lower.length + pivots.length), higher, compare);\n    }\n}\nfunction groupBy(data, compare) {\n    const result = [];\n    let currentGroup = undefined;\n    for (const element of data.slice(0).sort(compare)) {\n        if (!currentGroup || compare(currentGroup[0], element) !== 0) {\n            currentGroup = [element];\n            result.push(currentGroup);\n        }\n        else {\n            currentGroup.push(element);\n        }\n    }\n    return result;\n}\n/**\n * Splits the given items into a list of (non-empty) groups.\n * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.\n * The order of the items is preserved.\n */\nfunction* groupAdjacentBy(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nfunction forEachAdjacent(arr, f) {\n    for (let i = 0; i <= arr.length; i++) {\n        f(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\n    }\n}\nfunction forEachWithNeighbors(arr, f) {\n    for (let i = 0; i < arr.length; i++) {\n        f(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\n    }\n}\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nfunction sortedDiff(before, after, compare) {\n    const result = [];\n    function pushSplice(start, deleteCount, toInsert) {\n        if (deleteCount === 0 && toInsert.length === 0) {\n            return;\n        }\n        const latest = result[result.length - 1];\n        if (latest && latest.start + latest.deleteCount === start) {\n            latest.deleteCount += deleteCount;\n            latest.toInsert.push(...toInsert);\n        }\n        else {\n            result.push({ start, deleteCount, toInsert });\n        }\n    }\n    let beforeIdx = 0;\n    let afterIdx = 0;\n    while (true) {\n        if (beforeIdx === before.length) {\n            pushSplice(beforeIdx, 0, after.slice(afterIdx));\n            break;\n        }\n        if (afterIdx === after.length) {\n            pushSplice(beforeIdx, before.length - beforeIdx, []);\n            break;\n        }\n        const beforeElement = before[beforeIdx];\n        const afterElement = after[afterIdx];\n        const n = compare(beforeElement, afterElement);\n        if (n === 0) {\n            // equal\n            beforeIdx += 1;\n            afterIdx += 1;\n        }\n        else if (n < 0) {\n            // beforeElement is smaller -> before element removed\n            pushSplice(beforeIdx, 1, []);\n            beforeIdx += 1;\n        }\n        else if (n > 0) {\n            // beforeElement is greater -> after element added\n            pushSplice(beforeIdx, 0, [afterElement]);\n            afterIdx += 1;\n        }\n    }\n    return result;\n}\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nfunction delta(before, after, compare) {\n    const splices = sortedDiff(before, after, compare);\n    const removed = [];\n    const added = [];\n    for (const splice of splices) {\n        removed.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n        added.push(...splice.toInsert);\n    }\n    return { removed, added };\n}\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elements from array when sorted with compare.\n */\nfunction top(array, compare, n) {\n    if (n === 0) {\n        return [];\n    }\n    const result = array.slice(0, n).sort(compare);\n    topStep(array, compare, result, n, array.length);\n    return result;\n}\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elements from array when sorted with compare.\n */\nfunction topAsync(array, compare, n, batch, token) {\n    if (n === 0) {\n        return Promise.resolve([]);\n    }\n    return new Promise((resolve, reject) => {\n        (async () => {\n            const o = array.length;\n            const result = array.slice(0, n).sort(compare);\n            for (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n                if (i > n) {\n                    await new Promise(resolve => setTimeout(resolve)); // any other delay function would starve I/O\n                }\n                if (token && token.isCancellationRequested) {\n                    throw new errors_1.CancellationError();\n                }\n                topStep(array, compare, result, i, m);\n            }\n            return result;\n        })()\n            .then(resolve, reject);\n    });\n}\nfunction topStep(array, compare, result, i, m) {\n    for (const n = result.length; i < m; i++) {\n        const element = array[i];\n        if (compare(element, result[n - 1]) < 0) {\n            result.pop();\n            const j = (0, arraysFind_1.findFirstIdxMonotonousOrArrLen)(result, e => compare(element, e) < 0);\n            result.splice(j, 0, element);\n        }\n    }\n}\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nfunction coalesce(array) {\n    return array.filter((e) => !!e);\n}\n/**\n * Remove all falsy values from `array`. The original array IS modified.\n */\nfunction coalesceInPlace(array) {\n    let to = 0;\n    for (let i = 0; i < array.length; i++) {\n        if (!!array[i]) {\n            array[to] = array[i];\n            to += 1;\n        }\n    }\n    array.length = to;\n}\n/**\n * @deprecated Use `Array.copyWithin` instead\n */\nfunction move(array, from, to) {\n    array.splice(to, 0, array.splice(from, 1)[0]);\n}\n/**\n * @returns false if the provided object is an array and not empty.\n */\nfunction isFalsyOrEmpty(obj) {\n    return !Array.isArray(obj) || obj.length === 0;\n}\nfunction isNonEmptyArray(obj) {\n    return Array.isArray(obj) && obj.length > 0;\n}\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nfunction distinct(array, keyFn = value => value) {\n    const seen = new Set();\n    return array.filter(element => {\n        const key = keyFn(element);\n        if (seen.has(key)) {\n            return false;\n        }\n        seen.add(key);\n        return true;\n    });\n}\nfunction uniqueFilter(keyFn) {\n    const seen = new Set();\n    return element => {\n        const key = keyFn(element);\n        if (seen.has(key)) {\n            return false;\n        }\n        seen.add(key);\n        return true;\n    };\n}\nfunction firstOrDefault(array, notFoundValue) {\n    return array.length > 0 ? array[0] : notFoundValue;\n}\nfunction lastOrDefault(array, notFoundValue) {\n    return array.length > 0 ? array[array.length - 1] : notFoundValue;\n}\nfunction commonPrefixLength(one, other, equals = (a, b) => a === b) {\n    let result = 0;\n    for (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n        result++;\n    }\n    return result;\n}\nfunction range(arg, to) {\n    let from = typeof to === 'number' ? arg : 0;\n    if (typeof to === 'number') {\n        from = arg;\n    }\n    else {\n        from = 0;\n        to = arg;\n    }\n    const result = [];\n    if (from <= to) {\n        for (let i = from; i < to; i++) {\n            result.push(i);\n        }\n    }\n    else {\n        for (let i = from; i > to; i--) {\n            result.push(i);\n        }\n    }\n    return result;\n}\nfunction index(array, indexer, mapper) {\n    return array.reduce((r, t) => {\n        r[indexer(t)] = mapper ? mapper(t) : t;\n        return r;\n    }, Object.create(null));\n}\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nfunction insert(array, element) {\n    array.push(element);\n    return () => remove(array, element);\n}\n/**\n * Removes an element from an array if it can be found.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nfunction remove(array, element) {\n    const index = array.indexOf(element);\n    if (index > -1) {\n        array.splice(index, 1);\n        return element;\n    }\n    return undefined;\n}\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nfunction arrayInsert(target, insertIndex, insertArr) {\n    const before = target.slice(0, insertIndex);\n    const after = target.slice(insertIndex);\n    return before.concat(insertArr, after);\n}\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nfunction shuffle(array, _seed) {\n    let rand;\n    if (typeof _seed === 'number') {\n        let seed = _seed;\n        // Seeded random number generator in JS. Modified from:\n        // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n        rand = () => {\n            const x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n            return x - Math.floor(x);\n        };\n    }\n    else {\n        rand = Math.random;\n    }\n    for (let i = array.length - 1; i > 0; i -= 1) {\n        const j = Math.floor(rand() * (i + 1));\n        const temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n}\n/**\n * Pushes an element to the start of the array, if found.\n */\nfunction pushToStart(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.unshift(value);\n    }\n}\n/**\n * Pushes an element to the end of the array, if found.\n */\nfunction pushToEnd(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.push(value);\n    }\n}\nfunction pushMany(arr, items) {\n    for (const item of items) {\n        arr.push(item);\n    }\n}\nfunction mapArrayOrNot(items, fn) {\n    return Array.isArray(items) ?\n        items.map(fn) :\n        fn(items);\n}\nfunction asArray(x) {\n    return Array.isArray(x) ? x : [x];\n}\nfunction getRandomElement(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n}\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nfunction insertInto(array, start, newItems) {\n    const startIdx = getActualStartIndex(array, start);\n    const originalLength = array.length;\n    const newItemsLength = newItems.length;\n    array.length = originalLength + newItemsLength;\n    // Move the items after the start index, start from the end so that we don't overwrite any value.\n    for (let i = originalLength - 1; i >= startIdx; i--) {\n        array[i + newItemsLength] = array[i];\n    }\n    for (let i = 0; i < newItemsLength; i++) {\n        array[i + startIdx] = newItems[i];\n    }\n}\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nfunction splice(array, start, deleteCount, newItems) {\n    const index = getActualStartIndex(array, start);\n    let result = array.splice(index, deleteCount);\n    if (result === undefined) {\n        // see https://bugs.webkit.org/show_bug.cgi?id=261140\n        result = [];\n    }\n    insertInto(array, index, newItems);\n    return result;\n}\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex(array, start) {\n    return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\nvar CompareResult;\n(function (CompareResult) {\n    function isLessThan(result) {\n        return result < 0;\n    }\n    CompareResult.isLessThan = isLessThan;\n    function isLessThanOrEqual(result) {\n        return result <= 0;\n    }\n    CompareResult.isLessThanOrEqual = isLessThanOrEqual;\n    function isGreaterThan(result) {\n        return result > 0;\n    }\n    CompareResult.isGreaterThan = isGreaterThan;\n    function isNeitherLessOrGreaterThan(result) {\n        return result === 0;\n    }\n    CompareResult.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;\n    CompareResult.greaterThan = 1;\n    CompareResult.lessThan = -1;\n    CompareResult.neitherLessOrGreaterThan = 0;\n})(CompareResult || (exports.CompareResult = CompareResult = {}));\nfunction compareBy(selector, comparator) {\n    return (a, b) => comparator(selector(a), selector(b));\n}\nfunction tieBreakComparators(...comparators) {\n    return (item1, item2) => {\n        for (const comparator of comparators) {\n            const result = comparator(item1, item2);\n            if (!CompareResult.isNeitherLessOrGreaterThan(result)) {\n                return result;\n            }\n        }\n        return CompareResult.neitherLessOrGreaterThan;\n    };\n}\n/**\n * The natural order on numbers.\n*/\nconst numberComparator = (a, b) => a - b;\nexports.numberComparator = numberComparator;\nconst booleanComparator = (a, b) => (0, exports.numberComparator)(a ? 1 : 0, b ? 1 : 0);\nexports.booleanComparator = booleanComparator;\nfunction reverseOrder(comparator) {\n    return (a, b) => -comparator(a, b);\n}\nclass ArrayQueue {\n    /**\n     * Constructs a queue that is backed by the given array. Runtime is O(1).\n    */\n    constructor(items) {\n        this.items = items;\n        this.firstIdx = 0;\n        this.lastIdx = this.items.length - 1;\n    }\n    get length() {\n        return this.lastIdx - this.firstIdx + 1;\n    }\n    /**\n     * Consumes elements from the beginning of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n    */\n    takeWhile(predicate) {\n        // P(k) := k <= this.lastIdx && predicate(this.items[k])\n        // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n        let startIdx = this.firstIdx;\n        while (startIdx < this.items.length && predicate(this.items[startIdx])) {\n            startIdx++;\n        }\n        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n        this.firstIdx = startIdx;\n        return result;\n    }\n    /**\n     * Consumes elements from the end of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned.\n     * The result has the same order as the underlying array!\n    */\n    takeFromEndWhile(predicate) {\n        // P(k) := this.firstIdx >= k && predicate(this.items[k])\n        // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n        let endIdx = this.lastIdx;\n        while (endIdx >= 0 && predicate(this.items[endIdx])) {\n            endIdx--;\n        }\n        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n        this.lastIdx = endIdx;\n        return result;\n    }\n    peek() {\n        if (this.length === 0) {\n            return undefined;\n        }\n        return this.items[this.firstIdx];\n    }\n    peekLast() {\n        if (this.length === 0) {\n            return undefined;\n        }\n        return this.items[this.lastIdx];\n    }\n    dequeue() {\n        const result = this.items[this.firstIdx];\n        this.firstIdx++;\n        return result;\n    }\n    removeLast() {\n        const result = this.items[this.lastIdx];\n        this.lastIdx--;\n        return result;\n    }\n    takeCount(count) {\n        const result = this.items.slice(this.firstIdx, this.firstIdx + count);\n        this.firstIdx += count;\n        return result;\n    }\n}\nexports.ArrayQueue = ArrayQueue;\n/**\n * This class is faster than an iterator and array for lazy computed data.\n*/\nclass CallbackIterable {\n    static { this.empty = new CallbackIterable(_callback => { }); }\n    constructor(\n    /**\n     * Calls the callback for every item.\n     * Stops when the callback returns false.\n    */\n    iterate) {\n        this.iterate = iterate;\n    }\n    forEach(handler) {\n        this.iterate(item => { handler(item); return true; });\n    }\n    toArray() {\n        const result = [];\n        this.iterate(item => { result.push(item); return true; });\n        return result;\n    }\n    filter(predicate) {\n        return new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));\n    }\n    map(mapFn) {\n        return new CallbackIterable(cb => this.iterate(item => cb(mapFn(item))));\n    }\n    some(predicate) {\n        let result = false;\n        this.iterate(item => { result = predicate(item); return !result; });\n        return result;\n    }\n    findFirst(predicate) {\n        let result;\n        this.iterate(item => {\n            if (predicate(item)) {\n                result = item;\n                return false;\n            }\n            return true;\n        });\n        return result;\n    }\n    findLast(predicate) {\n        let result;\n        this.iterate(item => {\n            if (predicate(item)) {\n                result = item;\n            }\n            return true;\n        });\n        return result;\n    }\n    findLastMaxBy(comparator) {\n        let result;\n        let first = true;\n        this.iterate(item => {\n            if (first || CompareResult.isGreaterThan(comparator(item, result))) {\n                first = false;\n                result = item;\n            }\n            return true;\n        });\n        return result;\n    }\n}\nexports.CallbackIterable = CallbackIterable;\n/**\n * Represents a re-arrangement of items in an array.\n */\nclass Permutation {\n    constructor(_indexMap) {\n        this._indexMap = _indexMap;\n    }\n    /**\n     * Returns a permutation that sorts the given array according to the given compare function.\n     */\n    static createSortPermutation(arr, compareFn) {\n        const sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n        return new Permutation(sortIndices);\n    }\n    /**\n     * Returns a new array with the elements of the given array re-arranged according to this permutation.\n     */\n    apply(arr) {\n        return arr.map((_, index) => arr[this._indexMap[index]]);\n    }\n    /**\n     * Returns a new permutation that undoes the re-arrangement of this permutation.\n    */\n    inverse() {\n        const inverseIndexMap = this._indexMap.slice();\n        for (let i = 0; i < this._indexMap.length; i++) {\n            inverseIndexMap[this._indexMap[i]] = i;\n        }\n        return new Permutation(inverseIndexMap);\n    }\n}\nexports.Permutation = Permutation;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MonotonousArray = void 0;\nexports.findLast = findLast;\nexports.findLastIdx = findLastIdx;\nexports.findLastMonotonous = findLastMonotonous;\nexports.findLastIdxMonotonous = findLastIdxMonotonous;\nexports.findFirstMonotonous = findFirstMonotonous;\nexports.findFirstIdxMonotonousOrArrLen = findFirstIdxMonotonousOrArrLen;\nexports.findFirstIdxMonotonous = findFirstIdxMonotonous;\nexports.findFirstMax = findFirstMax;\nexports.findLastMax = findLastMax;\nexports.findFirstMin = findFirstMin;\nexports.findMaxIdx = findMaxIdx;\nexports.mapFindFirst = mapFindFirst;\nfunction findLast(array, predicate) {\n    const idx = findLastIdx(array, predicate);\n    if (idx === -1) {\n        return undefined;\n    }\n    return array[idx];\n}\nfunction findLastIdx(array, predicate, fromIndex = array.length - 1) {\n    for (let i = fromIndex; i >= 0; i--) {\n        const element = array[i];\n        if (predicate(element)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nfunction findLastMonotonous(array, predicate) {\n    const idx = findLastIdxMonotonous(array, predicate);\n    return idx === -1 ? undefined : array[idx];\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nfunction findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            i = k + 1;\n        }\n        else {\n            j = k;\n        }\n    }\n    return i - 1;\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nfunction findFirstMonotonous(array, predicate) {\n    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n    return idx === array.length ? undefined : array[idx];\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nfunction findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            j = k;\n        }\n        else {\n            i = k + 1;\n        }\n    }\n    return i;\n}\nfunction findFirstIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    const idx = findFirstIdxMonotonousOrArrLen(array, predicate, startIdx, endIdxEx);\n    return idx === array.length ? -1 : idx;\n}\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nclass MonotonousArray {\n    static { this.assertInvariants = false; }\n    constructor(_array) {\n        this._array = _array;\n        this._findLastMonotonousLastIdx = 0;\n    }\n    /**\n     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n     */\n    findLastMonotonous(predicate) {\n        if (MonotonousArray.assertInvariants) {\n            if (this._prevFindLastPredicate) {\n                for (const item of this._array) {\n                    if (this._prevFindLastPredicate(item) && !predicate(item)) {\n                        throw new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n                    }\n                }\n            }\n            this._prevFindLastPredicate = predicate;\n        }\n        const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n        this._findLastMonotonousLastIdx = idx + 1;\n        return idx === -1 ? undefined : this._array[idx];\n    }\n}\nexports.MonotonousArray = MonotonousArray;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nfunction findFirstMax(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) > 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nfunction findLastMax(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) >= 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nfunction findFirstMin(array, comparator) {\n    return findFirstMax(array, (a, b) => -comparator(a, b));\n}\nfunction findMaxIdx(array, comparator) {\n    if (array.length === 0) {\n        return -1;\n    }\n    let maxIdx = 0;\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, array[maxIdx]) > 0) {\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nfunction mapFindFirst(items, mapFn) {\n    for (const value of items) {\n        const mapped = mapFn(value);\n        if (mapped !== undefined) {\n            return mapped;\n        }\n    }\n    return undefined;\n}\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncIterableSource = exports.CancelableAsyncIterableObject = exports.AsyncIterableObject = exports.LazyStatefulPromise = exports.StatefulPromise = exports.Promises = exports.DeferredPromise = exports.IntervalCounter = exports.TaskSequentializer = exports.GlobalIdleValue = exports.AbstractIdleValue = exports._runWhenIdle = exports.runWhenGlobalIdle = exports.ThrottledWorker = exports.RunOnceWorker = exports.ProcessTimeRunOnceScheduler = exports.RunOnceScheduler = exports.IntervalTimer = exports.TimeoutTimer = exports.LimitedQueue = exports.Queue = exports.Limiter = exports.AutoOpenBarrier = exports.Barrier = exports.ThrottledDelayer = exports.Delayer = exports.SequencerByKey = exports.Sequencer = exports.Throttler = void 0;\nexports.isThenable = isThenable;\nexports.createCancelablePromise = createCancelablePromise;\nexports.raceCancellation = raceCancellation;\nexports.raceCancellationError = raceCancellationError;\nexports.raceCancellablePromises = raceCancellablePromises;\nexports.raceTimeout = raceTimeout;\nexports.asPromise = asPromise;\nexports.promiseWithResolvers = promiseWithResolvers;\nexports.timeout = timeout;\nexports.disposableTimeout = disposableTimeout;\nexports.sequence = sequence;\nexports.first = first;\nexports.firstParallel = firstParallel;\nexports.retry = retry;\nexports.createCancelableAsyncIterable = createCancelableAsyncIterable;\nconst cancellation_1 = require(\"vs/base/common/cancellation\");\nconst errors_1 = require(\"vs/base/common/errors\");\nconst event_1 = require(\"vs/base/common/event\");\nconst lifecycle_1 = require(\"vs/base/common/lifecycle\");\nconst platform_1 = require(\"vs/base/common/platform\");\nconst symbols_1 = require(\"./symbols\");\nconst lazy_1 = require(\"vs/base/common/lazy\");\nfunction isThenable(obj) {\n    return !!obj && typeof obj.then === 'function';\n}\nfunction createCancelablePromise(callback) {\n    const source = new cancellation_1.CancellationTokenSource();\n    const thenable = callback(source.token);\n    const promise = new Promise((resolve, reject) => {\n        const subscription = source.token.onCancellationRequested(() => {\n            subscription.dispose();\n            reject(new errors_1.CancellationError());\n        });\n        Promise.resolve(thenable).then(value => {\n            subscription.dispose();\n            source.dispose();\n            resolve(value);\n        }, err => {\n            subscription.dispose();\n            source.dispose();\n            reject(err);\n        });\n    });\n    return new class {\n        cancel() {\n            source.cancel();\n            source.dispose();\n        }\n        then(resolve, reject) {\n            return promise.then(resolve, reject);\n        }\n        catch(reject) {\n            return this.then(undefined, reject);\n        }\n        finally(onfinally) {\n            return promise.finally(onfinally);\n        }\n    };\n}\nfunction raceCancellation(promise, token, defaultValue) {\n    return new Promise((resolve, reject) => {\n        const ref = token.onCancellationRequested(() => {\n            ref.dispose();\n            resolve(defaultValue);\n        });\n        promise.then(resolve, reject).finally(() => ref.dispose());\n    });\n}\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nfunction raceCancellationError(promise, token) {\n    return new Promise((resolve, reject) => {\n        const ref = token.onCancellationRequested(() => {\n            ref.dispose();\n            reject(new errors_1.CancellationError());\n        });\n        promise.then(resolve, reject).finally(() => ref.dispose());\n    });\n}\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nasync function raceCancellablePromises(cancellablePromises) {\n    let resolvedPromiseIndex = -1;\n    const promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n    try {\n        const result = await Promise.race(promises);\n        return result;\n    }\n    finally {\n        cancellablePromises.forEach((cancellablePromise, index) => {\n            if (index !== resolvedPromiseIndex) {\n                cancellablePromise.cancel();\n            }\n        });\n    }\n}\nfunction raceTimeout(promise, timeout, onTimeout) {\n    let promiseResolve = undefined;\n    const timer = setTimeout(() => {\n        promiseResolve?.(undefined);\n        onTimeout?.();\n    }, timeout);\n    return Promise.race([\n        promise.finally(() => clearTimeout(timer)),\n        new Promise(resolve => promiseResolve = resolve)\n    ]);\n}\nfunction asPromise(callback) {\n    return new Promise((resolve, reject) => {\n        const item = callback();\n        if (isThenable(item)) {\n            item.then(resolve, reject);\n        }\n        else {\n            resolve(item);\n        }\n    });\n}\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nfunction promiseWithResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve: resolve, reject: reject };\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nclass Throttler {\n    constructor() {\n        this.isDisposed = false;\n        this.activePromise = null;\n        this.queuedPromise = null;\n        this.queuedPromiseFactory = null;\n    }\n    queue(promiseFactory) {\n        if (this.isDisposed) {\n            return Promise.reject(new Error('Throttler is disposed'));\n        }\n        if (this.activePromise) {\n            this.queuedPromiseFactory = promiseFactory;\n            if (!this.queuedPromise) {\n                const onComplete = () => {\n                    this.queuedPromise = null;\n                    if (this.isDisposed) {\n                        return;\n                    }\n                    const result = this.queue(this.queuedPromiseFactory);\n                    this.queuedPromiseFactory = null;\n                    return result;\n                };\n                this.queuedPromise = new Promise(resolve => {\n                    this.activePromise.then(onComplete, onComplete).then(resolve);\n                });\n            }\n            return new Promise((resolve, reject) => {\n                this.queuedPromise.then(resolve, reject);\n            });\n        }\n        this.activePromise = promiseFactory();\n        return new Promise((resolve, reject) => {\n            this.activePromise.then((result) => {\n                this.activePromise = null;\n                resolve(result);\n            }, (err) => {\n                this.activePromise = null;\n                reject(err);\n            });\n        });\n    }\n    dispose() {\n        this.isDisposed = true;\n    }\n}\nexports.Throttler = Throttler;\nclass Sequencer {\n    constructor() {\n        this.current = Promise.resolve(null);\n    }\n    queue(promiseTask) {\n        return this.current = this.current.then(() => promiseTask(), () => promiseTask());\n    }\n}\nexports.Sequencer = Sequencer;\nclass SequencerByKey {\n    constructor() {\n        this.promiseMap = new Map();\n    }\n    queue(key, promiseTask) {\n        const runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n        const newPromise = runningPromise\n            .catch(() => { })\n            .then(promiseTask)\n            .finally(() => {\n            if (this.promiseMap.get(key) === newPromise) {\n                this.promiseMap.delete(key);\n            }\n        });\n        this.promiseMap.set(key, newPromise);\n        return newPromise;\n    }\n}\nexports.SequencerByKey = SequencerByKey;\nconst timeoutDeferred = (timeout, fn) => {\n    let scheduled = true;\n    const handle = setTimeout(() => {\n        scheduled = false;\n        fn();\n    }, timeout);\n    return {\n        isTriggered: () => scheduled,\n        dispose: () => {\n            clearTimeout(handle);\n            scheduled = false;\n        },\n    };\n};\nconst microtaskDeferred = (fn) => {\n    let scheduled = true;\n    queueMicrotask(() => {\n        if (scheduled) {\n            scheduled = false;\n            fn();\n        }\n    });\n    return {\n        isTriggered: () => scheduled,\n        dispose: () => { scheduled = false; },\n    };\n};\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nclass Delayer {\n    constructor(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.deferred = null;\n        this.completionPromise = null;\n        this.doResolve = null;\n        this.doReject = null;\n        this.task = null;\n    }\n    trigger(task, delay = this.defaultDelay) {\n        this.task = task;\n        this.cancelTimeout();\n        if (!this.completionPromise) {\n            this.completionPromise = new Promise((resolve, reject) => {\n                this.doResolve = resolve;\n                this.doReject = reject;\n            }).then(() => {\n                this.completionPromise = null;\n                this.doResolve = null;\n                if (this.task) {\n                    const task = this.task;\n                    this.task = null;\n                    return task();\n                }\n                return undefined;\n            });\n        }\n        const fn = () => {\n            this.deferred = null;\n            this.doResolve?.(null);\n        };\n        this.deferred = delay === symbols_1.MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n        return this.completionPromise;\n    }\n    isTriggered() {\n        return !!this.deferred?.isTriggered();\n    }\n    cancel() {\n        this.cancelTimeout();\n        if (this.completionPromise) {\n            this.doReject?.(new errors_1.CancellationError());\n            this.completionPromise = null;\n        }\n    }\n    cancelTimeout() {\n        this.deferred?.dispose();\n        this.deferred = null;\n    }\n    dispose() {\n        this.cancel();\n    }\n}\nexports.Delayer = Delayer;\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nclass ThrottledDelayer {\n    constructor(defaultDelay) {\n        this.delayer = new Delayer(defaultDelay);\n        this.throttler = new Throttler();\n    }\n    trigger(promiseFactory, delay) {\n        return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n    }\n    isTriggered() {\n        return this.delayer.isTriggered();\n    }\n    cancel() {\n        this.delayer.cancel();\n    }\n    dispose() {\n        this.delayer.dispose();\n        this.throttler.dispose();\n    }\n}\nexports.ThrottledDelayer = ThrottledDelayer;\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nclass Barrier {\n    constructor() {\n        this._isOpen = false;\n        this._promise = new Promise((c, e) => {\n            this._completePromise = c;\n        });\n    }\n    isOpen() {\n        return this._isOpen;\n    }\n    open() {\n        this._isOpen = true;\n        this._completePromise(true);\n    }\n    wait() {\n        return this._promise;\n    }\n}\nexports.Barrier = Barrier;\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nclass AutoOpenBarrier extends Barrier {\n    constructor(autoOpenTimeMs) {\n        super();\n        this._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n    }\n    open() {\n        clearTimeout(this._timeout);\n        super.open();\n    }\n}\nexports.AutoOpenBarrier = AutoOpenBarrier;\nfunction timeout(millis, token) {\n    if (!token) {\n        return createCancelablePromise(token => timeout(millis, token));\n    }\n    return new Promise((resolve, reject) => {\n        const handle = setTimeout(() => {\n            disposable.dispose();\n            resolve();\n        }, millis);\n        const disposable = token.onCancellationRequested(() => {\n            clearTimeout(handle);\n            disposable.dispose();\n            reject(new errors_1.CancellationError());\n        });\n    });\n}\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nfunction disposableTimeout(handler, timeout = 0, store) {\n    const timer = setTimeout(() => {\n        handler();\n        if (store) {\n            disposable.dispose();\n        }\n    }, timeout);\n    const disposable = (0, lifecycle_1.toDisposable)(() => {\n        clearTimeout(timer);\n        store?.deleteAndLeak(disposable);\n    });\n    store?.add(disposable);\n    return disposable;\n}\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\nfunction sequence(promiseFactories) {\n    const results = [];\n    let index = 0;\n    const len = promiseFactories.length;\n    function next() {\n        return index < len ? promiseFactories[index++]() : null;\n    }\n    function thenHandler(result) {\n        if (result !== undefined && result !== null) {\n            results.push(result);\n        }\n        const n = next();\n        if (n) {\n            return n.then(thenHandler);\n        }\n        return Promise.resolve(results);\n    }\n    return Promise.resolve(null).then(thenHandler);\n}\nfunction first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n    let index = 0;\n    const len = promiseFactories.length;\n    const loop = () => {\n        if (index >= len) {\n            return Promise.resolve(defaultValue);\n        }\n        const factory = promiseFactories[index++];\n        const promise = Promise.resolve(factory());\n        return promise.then(result => {\n            if (shouldStop(result)) {\n                return Promise.resolve(result);\n            }\n            return loop();\n        });\n    };\n    return loop();\n}\nfunction firstParallel(promiseList, shouldStop = t => !!t, defaultValue = null) {\n    if (promiseList.length === 0) {\n        return Promise.resolve(defaultValue);\n    }\n    let todo = promiseList.length;\n    const finish = () => {\n        todo = -1;\n        for (const promise of promiseList) {\n            promise.cancel?.();\n        }\n    };\n    return new Promise((resolve, reject) => {\n        for (const promise of promiseList) {\n            promise.then(result => {\n                if (--todo >= 0 && shouldStop(result)) {\n                    finish();\n                    resolve(result);\n                }\n                else if (todo === 0) {\n                    resolve(defaultValue);\n                }\n            })\n                .catch(err => {\n                if (--todo >= 0) {\n                    finish();\n                    reject(err);\n                }\n            });\n        }\n    });\n}\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nclass Limiter {\n    constructor(maxDegreeOfParalellism) {\n        this._size = 0;\n        this._isDisposed = false;\n        this.maxDegreeOfParalellism = maxDegreeOfParalellism;\n        this.outstandingPromises = [];\n        this.runningPromises = 0;\n        this._onDrained = new event_1.Emitter();\n    }\n    /**\n     *\n     * @returns A promise that resolved when all work is done (onDrained) or when\n     * there is nothing to do\n     */\n    whenIdle() {\n        return this.size > 0\n            ? event_1.Event.toPromise(this.onDrained)\n            : Promise.resolve();\n    }\n    get onDrained() {\n        return this._onDrained.event;\n    }\n    get size() {\n        return this._size;\n    }\n    queue(factory) {\n        if (this._isDisposed) {\n            throw new Error('Object has been disposed');\n        }\n        this._size++;\n        return new Promise((c, e) => {\n            this.outstandingPromises.push({ factory, c, e });\n            this.consume();\n        });\n    }\n    consume() {\n        while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n            const iLimitedTask = this.outstandingPromises.shift();\n            this.runningPromises++;\n            const promise = iLimitedTask.factory();\n            promise.then(iLimitedTask.c, iLimitedTask.e);\n            promise.then(() => this.consumed(), () => this.consumed());\n        }\n    }\n    consumed() {\n        if (this._isDisposed) {\n            return;\n        }\n        this.runningPromises--;\n        if (--this._size === 0) {\n            this._onDrained.fire();\n        }\n        if (this.outstandingPromises.length > 0) {\n            this.consume();\n        }\n    }\n    clear() {\n        if (this._isDisposed) {\n            throw new Error('Object has been disposed');\n        }\n        this.outstandingPromises.length = 0;\n        this._size = this.runningPromises;\n    }\n    dispose() {\n        this._isDisposed = true;\n        this.outstandingPromises.length = 0; // stop further processing\n        this._size = 0;\n        this._onDrained.dispose();\n    }\n}\nexports.Limiter = Limiter;\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nclass Queue extends Limiter {\n    constructor() {\n        super(1);\n    }\n}\nexports.Queue = Queue;\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nclass LimitedQueue {\n    constructor() {\n        this.sequentializer = new TaskSequentializer();\n        this.tasks = 0;\n    }\n    queue(factory) {\n        if (!this.sequentializer.isRunning()) {\n            return this.sequentializer.run(this.tasks++, factory());\n        }\n        return this.sequentializer.queue(() => {\n            return this.sequentializer.run(this.tasks++, factory());\n        });\n    }\n}\nexports.LimitedQueue = LimitedQueue;\nclass TimeoutTimer {\n    constructor(runner, timeout) {\n        this._isDisposed = false;\n        this._token = -1;\n        if (typeof runner === 'function' && typeof timeout === 'number') {\n            this.setIfNotSet(runner, timeout);\n        }\n    }\n    dispose() {\n        this.cancel();\n        this._isDisposed = true;\n    }\n    cancel() {\n        if (this._token !== -1) {\n            clearTimeout(this._token);\n            this._token = -1;\n        }\n    }\n    cancelAndSet(runner, timeout) {\n        if (this._isDisposed) {\n            throw new errors_1.BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n        }\n        this.cancel();\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n    setIfNotSet(runner, timeout) {\n        if (this._isDisposed) {\n            throw new errors_1.BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n        }\n        if (this._token !== -1) {\n            // timer is already set\n            return;\n        }\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n}\nexports.TimeoutTimer = TimeoutTimer;\nclass IntervalTimer {\n    constructor() {\n        this.disposable = undefined;\n        this.isDisposed = false;\n    }\n    cancel() {\n        this.disposable?.dispose();\n        this.disposable = undefined;\n    }\n    cancelAndSet(runner, interval, context = globalThis) {\n        if (this.isDisposed) {\n            throw new errors_1.BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n        }\n        this.cancel();\n        const handle = context.setInterval(() => {\n            runner();\n        }, interval);\n        this.disposable = (0, lifecycle_1.toDisposable)(() => {\n            context.clearInterval(handle);\n            this.disposable = undefined;\n        });\n    }\n    dispose() {\n        this.cancel();\n        this.isDisposed = true;\n    }\n}\nexports.IntervalTimer = IntervalTimer;\nclass RunOnceScheduler {\n    constructor(runner, delay) {\n        this.timeoutToken = -1;\n        this.runner = runner;\n        this.timeout = delay;\n        this.timeoutHandler = this.onTimeout.bind(this);\n    }\n    /**\n     * Dispose RunOnceScheduler\n     */\n    dispose() {\n        this.cancel();\n        this.runner = null;\n    }\n    /**\n     * Cancel current scheduled runner (if any).\n     */\n    cancel() {\n        if (this.isScheduled()) {\n            clearTimeout(this.timeoutToken);\n            this.timeoutToken = -1;\n        }\n    }\n    /**\n     * Cancel previous runner (if any) & schedule a new runner.\n     */\n    schedule(delay = this.timeout) {\n        this.cancel();\n        this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n    }\n    get delay() {\n        return this.timeout;\n    }\n    set delay(value) {\n        this.timeout = value;\n    }\n    /**\n     * Returns true if scheduled.\n     */\n    isScheduled() {\n        return this.timeoutToken !== -1;\n    }\n    flush() {\n        if (this.isScheduled()) {\n            this.cancel();\n            this.doRun();\n        }\n    }\n    onTimeout() {\n        this.timeoutToken = -1;\n        if (this.runner) {\n            this.doRun();\n        }\n    }\n    doRun() {\n        this.runner?.();\n    }\n}\nexports.RunOnceScheduler = RunOnceScheduler;\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nclass ProcessTimeRunOnceScheduler {\n    constructor(runner, delay) {\n        if (delay % 1000 !== 0) {\n            console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n        }\n        this.runner = runner;\n        this.timeout = delay;\n        this.counter = 0;\n        this.intervalToken = -1;\n        this.intervalHandler = this.onInterval.bind(this);\n    }\n    dispose() {\n        this.cancel();\n        this.runner = null;\n    }\n    cancel() {\n        if (this.isScheduled()) {\n            clearInterval(this.intervalToken);\n            this.intervalToken = -1;\n        }\n    }\n    /**\n     * Cancel previous runner (if any) & schedule a new runner.\n     */\n    schedule(delay = this.timeout) {\n        if (delay % 1000 !== 0) {\n            console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n        }\n        this.cancel();\n        this.counter = Math.ceil(delay / 1000);\n        this.intervalToken = setInterval(this.intervalHandler, 1000);\n    }\n    /**\n     * Returns true if scheduled.\n     */\n    isScheduled() {\n        return this.intervalToken !== -1;\n    }\n    onInterval() {\n        this.counter--;\n        if (this.counter > 0) {\n            // still need to wait\n            return;\n        }\n        // time elapsed\n        clearInterval(this.intervalToken);\n        this.intervalToken = -1;\n        this.runner?.();\n    }\n}\nexports.ProcessTimeRunOnceScheduler = ProcessTimeRunOnceScheduler;\nclass RunOnceWorker extends RunOnceScheduler {\n    constructor(runner, timeout) {\n        super(runner, timeout);\n        this.units = [];\n    }\n    work(unit) {\n        this.units.push(unit);\n        if (!this.isScheduled()) {\n            this.schedule();\n        }\n    }\n    doRun() {\n        const units = this.units;\n        this.units = [];\n        this.runner?.(units);\n    }\n    dispose() {\n        this.units = [];\n        super.dispose();\n    }\n}\nexports.RunOnceWorker = RunOnceWorker;\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nclass ThrottledWorker extends lifecycle_1.Disposable {\n    constructor(options, handler) {\n        super();\n        this.options = options;\n        this.handler = handler;\n        this.pendingWork = [];\n        this.throttler = this._register(new lifecycle_1.MutableDisposable());\n        this.disposed = false;\n    }\n    /**\n     * The number of work units that are pending to be processed.\n     */\n    get pending() { return this.pendingWork.length; }\n    /**\n     * Add units to be worked on. Use `pending` to figure out\n     * how many units are not yet processed after this method\n     * was called.\n     *\n     * @returns whether the work was accepted or not. If the\n     * worker is disposed, it will not accept any more work.\n     * If the number of pending units would become larger\n     * than `maxPendingWork`, more work will also not be accepted.\n     */\n    work(units) {\n        if (this.disposed) {\n            return false; // work not accepted: disposed\n        }\n        // Check for reaching maximum of pending work\n        if (typeof this.options.maxBufferedWork === 'number') {\n            // Throttled: simple check if pending + units exceeds max pending\n            if (this.throttler.value) {\n                if (this.pending + units.length > this.options.maxBufferedWork) {\n                    return false; // work not accepted: too much pending work\n                }\n            }\n            // Unthrottled: same as throttled, but account for max chunk getting\n            // worked on directly without being pending\n            else {\n                if (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n                    return false; // work not accepted: too much pending work\n                }\n            }\n        }\n        // Add to pending units first\n        for (const unit of units) {\n            this.pendingWork.push(unit);\n        }\n        // If not throttled, start working directly\n        // Otherwise, when the throttle delay has\n        // past, pending work will be worked again.\n        if (!this.throttler.value) {\n            this.doWork();\n        }\n        return true; // work accepted\n    }\n    doWork() {\n        // Extract chunk to handle and handle it\n        this.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n        // If we have remaining work, schedule it after a delay\n        if (this.pendingWork.length > 0) {\n            this.throttler.value = new RunOnceScheduler(() => {\n                this.throttler.clear();\n                this.doWork();\n            }, this.options.throttleDelay);\n            this.throttler.value.schedule();\n        }\n    }\n    dispose() {\n        super.dispose();\n        this.disposed = true;\n    }\n}\nexports.ThrottledWorker = ThrottledWorker;\n(function () {\n    if (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {\n        exports._runWhenIdle = (_targetWindow, runner) => {\n            (0, platform_1.setTimeout0)(() => {\n                if (disposed) {\n                    return;\n                }\n                const end = Date.now() + 15; // one frame at 64fps\n                const deadline = {\n                    didTimeout: true,\n                    timeRemaining() {\n                        return Math.max(0, end - Date.now());\n                    }\n                };\n                runner(Object.freeze(deadline));\n            });\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                }\n            };\n        };\n    }\n    else {\n        exports._runWhenIdle = (targetWindow, runner, timeout) => {\n            const handle = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                    targetWindow.cancelIdleCallback(handle);\n                }\n            };\n        };\n    }\n    exports.runWhenGlobalIdle = (runner) => (0, exports._runWhenIdle)(globalThis, runner);\n})();\nclass AbstractIdleValue {\n    constructor(targetWindow, executor) {\n        this._didRun = false;\n        this._executor = () => {\n            try {\n                this._value = executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        };\n        this._handle = (0, exports._runWhenIdle)(targetWindow, () => this._executor());\n    }\n    dispose() {\n        this._handle.dispose();\n    }\n    get value() {\n        if (!this._didRun) {\n            this._handle.dispose();\n            this._executor();\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n    get isInitialized() {\n        return this._didRun;\n    }\n}\nexports.AbstractIdleValue = AbstractIdleValue;\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nclass GlobalIdleValue extends AbstractIdleValue {\n    constructor(executor) {\n        super(globalThis, executor);\n    }\n}\nexports.GlobalIdleValue = GlobalIdleValue;\n//#endregion\nasync function retry(task, delay, retries) {\n    let lastError;\n    for (let i = 0; i < retries; i++) {\n        try {\n            return await task();\n        }\n        catch (error) {\n            lastError = error;\n            await timeout(delay);\n        }\n    }\n    throw lastError;\n}\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nclass TaskSequentializer {\n    isRunning(taskId) {\n        if (typeof taskId === 'number') {\n            return this._running?.taskId === taskId;\n        }\n        return !!this._running;\n    }\n    get running() {\n        return this._running?.promise;\n    }\n    cancelRunning() {\n        this._running?.cancel();\n    }\n    run(taskId, promise, onCancel) {\n        this._running = { taskId, cancel: () => onCancel?.(), promise };\n        promise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n        return promise;\n    }\n    doneRunning(taskId) {\n        if (this._running && taskId === this._running.taskId) {\n            // only set running to done if the promise finished that is associated with that taskId\n            this._running = undefined;\n            // schedule the queued task now that we are free if we have any\n            this.runQueued();\n        }\n    }\n    runQueued() {\n        if (this._queued) {\n            const queued = this._queued;\n            this._queued = undefined;\n            // Run queued task and complete on the associated promise\n            queued.run().then(queued.promiseResolve, queued.promiseReject);\n        }\n    }\n    /**\n     * Note: the promise to schedule as next run MUST itself call `run`.\n     *       Otherwise, this sequentializer will report `false` for `isRunning`\n     *       even when this task is running. Missing this detail means that\n     *       suddenly multiple tasks will run in parallel.\n     */\n    queue(run) {\n        // this is our first queued task, so we create associated promise with it\n        // so that we can return a promise that completes when the task has\n        // completed.\n        if (!this._queued) {\n            const { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers();\n            this._queued = {\n                run,\n                promise,\n                promiseResolve: promiseResolve,\n                promiseReject: promiseReject\n            };\n        }\n        // we have a previous queued task, just overwrite it\n        else {\n            this._queued.run = run;\n        }\n        return this._queued.promise;\n    }\n    hasQueued() {\n        return !!this._queued;\n    }\n    async join() {\n        return this._queued?.promise ?? this._running?.promise;\n    }\n}\nexports.TaskSequentializer = TaskSequentializer;\n//#endregion\n//#region\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nclass IntervalCounter {\n    constructor(interval, nowFn = () => Date.now()) {\n        this.interval = interval;\n        this.nowFn = nowFn;\n        this.lastIncrementTime = 0;\n        this.value = 0;\n    }\n    increment() {\n        const now = this.nowFn();\n        // We are outside of the range of `interval` and as such\n        // start counting from 0 and remember the time\n        if (now - this.lastIncrementTime > this.interval) {\n            this.lastIncrementTime = now;\n            this.value = 0;\n        }\n        this.value++;\n        return this.value;\n    }\n}\nexports.IntervalCounter = IntervalCounter;\nvar DeferredOutcome;\n(function (DeferredOutcome) {\n    DeferredOutcome[DeferredOutcome[\"Resolved\"] = 0] = \"Resolved\";\n    DeferredOutcome[DeferredOutcome[\"Rejected\"] = 1] = \"Rejected\";\n})(DeferredOutcome || (DeferredOutcome = {}));\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nclass DeferredPromise {\n    get isRejected() {\n        return this.outcome?.outcome === DeferredOutcome.Rejected;\n    }\n    get isResolved() {\n        return this.outcome?.outcome === DeferredOutcome.Resolved;\n    }\n    get isSettled() {\n        return !!this.outcome;\n    }\n    get value() {\n        return this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n    }\n    constructor() {\n        this.p = new Promise((c, e) => {\n            this.completeCallback = c;\n            this.errorCallback = e;\n        });\n    }\n    complete(value) {\n        return new Promise(resolve => {\n            this.completeCallback(value);\n            this.outcome = { outcome: DeferredOutcome.Resolved, value };\n            resolve();\n        });\n    }\n    error(err) {\n        return new Promise(resolve => {\n            this.errorCallback(err);\n            this.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n            resolve();\n        });\n    }\n    cancel() {\n        return this.error(new errors_1.CancellationError());\n    }\n}\nexports.DeferredPromise = DeferredPromise;\n//#endregion\n//#region Promises\nvar Promises;\n(function (Promises) {\n    /**\n     * A drop-in replacement for `Promise.all` with the only difference\n     * that the method awaits every promise to either fulfill or reject.\n     *\n     * Similar to `Promise.all`, only the first error will be returned\n     * if any.\n     */\n    async function settled(promises) {\n        let firstError = undefined;\n        const result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n            if (!firstError) {\n                firstError = error;\n            }\n            return undefined; // do not rethrow so that other promises can settle\n        })));\n        if (typeof firstError !== 'undefined') {\n            throw firstError;\n        }\n        return result; // cast is needed and protected by the `throw` above\n    }\n    Promises.settled = settled;\n    /**\n     * A helper to create a new `Promise<T>` with a body that is a promise\n     * itself. By default, an error that raises from the async body will\n     * end up as a unhandled rejection, so this utility properly awaits the\n     * body and rejects the promise as a normal promise does without async\n     * body.\n     *\n     * This method should only be used in rare cases where otherwise `async`\n     * cannot be used (e.g. when callbacks are involved that require this).\n     */\n    function withAsyncBody(bodyFn) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async (resolve, reject) => {\n            try {\n                await bodyFn(resolve, reject);\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    }\n    Promises.withAsyncBody = withAsyncBody;\n})(Promises || (exports.Promises = Promises = {}));\nclass StatefulPromise {\n    get value() { return this._value; }\n    get error() { return this._error; }\n    get isResolved() { return this._isResolved; }\n    constructor(promise) {\n        this._value = undefined;\n        this._error = undefined;\n        this._isResolved = false;\n        this.promise = promise.then(value => {\n            this._value = value;\n            this._isResolved = true;\n            return value;\n        }, error => {\n            this._error = error;\n            this._isResolved = true;\n            throw error;\n        });\n    }\n    /**\n     * Returns the resolved value.\n     * Throws if the promise is not resolved yet.\n     */\n    requireValue() {\n        if (!this._isResolved) {\n            throw new errors_1.BugIndicatingError('Promise is not resolved yet');\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n}\nexports.StatefulPromise = StatefulPromise;\nclass LazyStatefulPromise {\n    constructor(_compute) {\n        this._compute = _compute;\n        this._promise = new lazy_1.Lazy(() => new StatefulPromise(this._compute()));\n    }\n    /**\n     * Returns the resolved value.\n     * Throws if the promise is not resolved yet.\n     */\n    requireValue() {\n        return this._promise.value.requireValue();\n    }\n    /**\n     * Returns the promise (and triggers a computation of the promise if not yet done so).\n     */\n    getPromise() {\n        return this._promise.value.promise;\n    }\n    /**\n     * Reads the current value without triggering a computation of the promise.\n     */\n    get currentValue() {\n        return this._promise.rawValue?.value;\n    }\n}\nexports.LazyStatefulPromise = LazyStatefulPromise;\n//#endregion\n//#region\nvar AsyncIterableSourceState;\n(function (AsyncIterableSourceState) {\n    AsyncIterableSourceState[AsyncIterableSourceState[\"Initial\"] = 0] = \"Initial\";\n    AsyncIterableSourceState[AsyncIterableSourceState[\"DoneOK\"] = 1] = \"DoneOK\";\n    AsyncIterableSourceState[AsyncIterableSourceState[\"DoneError\"] = 2] = \"DoneError\";\n})(AsyncIterableSourceState || (AsyncIterableSourceState = {}));\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nclass AsyncIterableObject {\n    static fromArray(items) {\n        return new AsyncIterableObject((writer) => {\n            writer.emitMany(items);\n        });\n    }\n    static fromPromise(promise) {\n        return new AsyncIterableObject(async (emitter) => {\n            emitter.emitMany(await promise);\n        });\n    }\n    static fromPromises(promises) {\n        return new AsyncIterableObject(async (emitter) => {\n            await Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n        });\n    }\n    static merge(iterables) {\n        return new AsyncIterableObject(async (emitter) => {\n            await Promise.all(iterables.map(async (iterable) => {\n                for await (const item of iterable) {\n                    emitter.emitOne(item);\n                }\n            }));\n        });\n    }\n    static { this.EMPTY = AsyncIterableObject.fromArray([]); }\n    constructor(executor, onReturn) {\n        this._state = AsyncIterableSourceState.Initial;\n        this._results = [];\n        this._error = null;\n        this._onReturn = onReturn;\n        this._onStateChanged = new event_1.Emitter();\n        queueMicrotask(async () => {\n            const writer = {\n                emitOne: (item) => this.emitOne(item),\n                emitMany: (items) => this.emitMany(items),\n                reject: (error) => this.reject(error)\n            };\n            try {\n                await Promise.resolve(executor(writer));\n                this.resolve();\n            }\n            catch (err) {\n                this.reject(err);\n            }\n            finally {\n                writer.emitOne = undefined;\n                writer.emitMany = undefined;\n                writer.reject = undefined;\n            }\n        });\n    }\n    [Symbol.asyncIterator]() {\n        let i = 0;\n        return {\n            next: async () => {\n                do {\n                    if (this._state === AsyncIterableSourceState.DoneError) {\n                        throw this._error;\n                    }\n                    if (i < this._results.length) {\n                        return { done: false, value: this._results[i++] };\n                    }\n                    if (this._state === AsyncIterableSourceState.DoneOK) {\n                        return { done: true, value: undefined };\n                    }\n                    await event_1.Event.toPromise(this._onStateChanged.event);\n                } while (true);\n            },\n            return: async () => {\n                this._onReturn?.();\n                return { done: true, value: undefined };\n            }\n        };\n    }\n    static map(iterable, mapFn) {\n        return new AsyncIterableObject(async (emitter) => {\n            for await (const item of iterable) {\n                emitter.emitOne(mapFn(item));\n            }\n        });\n    }\n    map(mapFn) {\n        return AsyncIterableObject.map(this, mapFn);\n    }\n    static filter(iterable, filterFn) {\n        return new AsyncIterableObject(async (emitter) => {\n            for await (const item of iterable) {\n                if (filterFn(item)) {\n                    emitter.emitOne(item);\n                }\n            }\n        });\n    }\n    filter(filterFn) {\n        return AsyncIterableObject.filter(this, filterFn);\n    }\n    static coalesce(iterable) {\n        return AsyncIterableObject.filter(iterable, item => !!item);\n    }\n    coalesce() {\n        return AsyncIterableObject.coalesce(this);\n    }\n    static async toPromise(iterable) {\n        const result = [];\n        for await (const item of iterable) {\n            result.push(item);\n        }\n        return result;\n    }\n    toPromise() {\n        return AsyncIterableObject.toPromise(this);\n    }\n    /**\n     * The value will be appended at the end.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    emitOne(value) {\n        if (this._state !== AsyncIterableSourceState.Initial) {\n            return;\n        }\n        // it is important to add new values at the end,\n        // as we may have iterators already running on the array\n        this._results.push(value);\n        this._onStateChanged.fire();\n    }\n    /**\n     * The values will be appended at the end.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    emitMany(values) {\n        if (this._state !== AsyncIterableSourceState.Initial) {\n            return;\n        }\n        // it is important to add new values at the end,\n        // as we may have iterators already running on the array\n        this._results = this._results.concat(values);\n        this._onStateChanged.fire();\n    }\n    /**\n     * Calling `resolve()` will mark the result array as complete.\n     *\n     * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    resolve() {\n        if (this._state !== AsyncIterableSourceState.Initial) {\n            return;\n        }\n        this._state = AsyncIterableSourceState.DoneOK;\n        this._onStateChanged.fire();\n    }\n    /**\n     * Writing an error will permanently invalidate this iterable.\n     * The current users will receive an error thrown, as will all future users.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    reject(error) {\n        if (this._state !== AsyncIterableSourceState.Initial) {\n            return;\n        }\n        this._state = AsyncIterableSourceState.DoneError;\n        this._error = error;\n        this._onStateChanged.fire();\n    }\n}\nexports.AsyncIterableObject = AsyncIterableObject;\nclass CancelableAsyncIterableObject extends AsyncIterableObject {\n    constructor(_source, executor) {\n        super(executor);\n        this._source = _source;\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nexports.CancelableAsyncIterableObject = CancelableAsyncIterableObject;\nfunction createCancelableAsyncIterable(callback) {\n    const source = new cancellation_1.CancellationTokenSource();\n    const innerIterable = callback(source.token);\n    return new CancelableAsyncIterableObject(source, async (emitter) => {\n        const subscription = source.token.onCancellationRequested(() => {\n            subscription.dispose();\n            source.dispose();\n            emitter.reject(new errors_1.CancellationError());\n        });\n        try {\n            for await (const item of innerIterable) {\n                if (source.token.isCancellationRequested) {\n                    // canceled in the meantime\n                    return;\n                }\n                emitter.emitOne(item);\n            }\n            subscription.dispose();\n            source.dispose();\n        }\n        catch (err) {\n            subscription.dispose();\n            source.dispose();\n            emitter.reject(err);\n        }\n    });\n}\nclass AsyncIterableSource {\n    /**\n     *\n     * @param onReturn A function that will be called when consuming the async iterable\n     * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.\n     * This is NOT called when resolving this source by its owner.\n     */\n    constructor(onReturn) {\n        this._deferred = new DeferredPromise();\n        this._asyncIterable = new AsyncIterableObject(emitter => {\n            if (earlyError) {\n                emitter.reject(earlyError);\n                return;\n            }\n            if (earlyItems) {\n                emitter.emitMany(earlyItems);\n            }\n            this._errorFn = (error) => emitter.reject(error);\n            this._emitFn = (item) => emitter.emitOne(item);\n            return this._deferred.p;\n        }, onReturn);\n        let earlyError;\n        let earlyItems;\n        this._emitFn = (item) => {\n            if (!earlyItems) {\n                earlyItems = [];\n            }\n            earlyItems.push(item);\n        };\n        this._errorFn = (error) => {\n            if (!earlyError) {\n                earlyError = error;\n            }\n        };\n    }\n    get asyncIterable() {\n        return this._asyncIterable;\n    }\n    resolve() {\n        this._deferred.complete();\n    }\n    reject(error) {\n        this._errorFn(error);\n        this._deferred.complete();\n    }\n    emitOne(item) {\n        this._emitFn(item);\n    }\n}\nexports.AsyncIterableSource = AsyncIterableSource;\n//#endregion\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CancellationTokenSource = exports.CancellationToken = void 0;\nexports.cancelOnDispose = cancelOnDispose;\nconst event_1 = require(\"vs/base/common/event\");\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = setTimeout(callback.bind(context), 0);\n    return { dispose() { clearTimeout(handle); } };\n});\nvar CancellationToken;\n(function (CancellationToken) {\n    function isCancellationToken(thing) {\n        if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n            return true;\n        }\n        if (thing instanceof MutableToken) {\n            return true;\n        }\n        if (!thing || typeof thing !== 'object') {\n            return false;\n        }\n        return typeof thing.isCancellationRequested === 'boolean'\n            && typeof thing.onCancellationRequested === 'function';\n    }\n    CancellationToken.isCancellationToken = isCancellationToken;\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: event_1.Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: shortcutEvent\n    });\n})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n        this._emitter = null;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new event_1.Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = null;\n        }\n    }\n}\nclass CancellationTokenSource {\n    constructor(parent) {\n        this._token = undefined;\n        this._parentListener = undefined;\n        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n    }\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually cancel\n            this._token.cancel();\n        }\n    }\n    dispose(cancel = false) {\n        if (cancel) {\n            this.cancel();\n        }\n        this._parentListener?.dispose();\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\nexports.CancellationTokenSource = CancellationTokenSource;\nfunction cancelOnDispose(store) {\n    const source = new CancellationTokenSource();\n    store.add({ dispose() { source.cancel(); } });\n    return source.token;\n}\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetWithKey = void 0;\nexports.groupBy = groupBy;\nexports.diffSets = diffSets;\nexports.diffMaps = diffMaps;\nexports.intersection = intersection;\n/**\n * Groups the collection into a dictionary based on the provided\n * group function.\n */\nfunction groupBy(data, groupFn) {\n    const result = Object.create(null);\n    for (const element of data) {\n        const key = groupFn(element);\n        let target = result[key];\n        if (!target) {\n            target = result[key] = [];\n        }\n        target.push(element);\n    }\n    return result;\n}\nfunction diffSets(before, after) {\n    const removed = [];\n    const added = [];\n    for (const element of before) {\n        if (!after.has(element)) {\n            removed.push(element);\n        }\n    }\n    for (const element of after) {\n        if (!before.has(element)) {\n            added.push(element);\n        }\n    }\n    return { removed, added };\n}\nfunction diffMaps(before, after) {\n    const removed = [];\n    const added = [];\n    for (const [index, value] of before) {\n        if (!after.has(index)) {\n            removed.push(value);\n        }\n    }\n    for (const [index, value] of after) {\n        if (!before.has(index)) {\n            added.push(value);\n        }\n    }\n    return { removed, added };\n}\n/**\n * Computes the intersection of two sets.\n *\n * @param setA - The first set.\n * @param setB - The second iterable.\n * @returns A new set containing the elements that are in both `setA` and `setB`.\n */\nfunction intersection(setA, setB) {\n    const result = new Set();\n    for (const elem of setB) {\n        if (setA.has(elem)) {\n            result.add(elem);\n        }\n    }\n    return result;\n}\nclass SetWithKey {\n    static { _a = Symbol.toStringTag; }\n    constructor(values, toKey) {\n        this.toKey = toKey;\n        this._map = new Map();\n        this[_a] = 'SetWithKey';\n        for (const value of values) {\n            this.add(value);\n        }\n    }\n    get size() {\n        return this._map.size;\n    }\n    add(value) {\n        const key = this.toKey(value);\n        this._map.set(key, value);\n        return this;\n    }\n    delete(value) {\n        return this._map.delete(this.toKey(value));\n    }\n    has(value) {\n        return this._map.has(this.toKey(value));\n    }\n    *entries() {\n        for (const entry of this._map.values()) {\n            yield [entry, entry];\n        }\n    }\n    keys() {\n        return this.values();\n    }\n    *values() {\n        for (const entry of this._map.values()) {\n            yield entry;\n        }\n    }\n    clear() {\n        this._map.clear();\n    }\n    forEach(callbackfn, thisArg) {\n        this._map.forEach(entry => callbackfn.call(thisArg, entry, entry, this));\n    }\n    [Symbol.iterator]() {\n        return this.values();\n    }\n}\nexports.SetWithKey = SetWithKey;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BugIndicatingError = exports.ErrorNoTelemetry = exports.ExpectedError = exports.NotSupportedError = exports.NotImplementedError = exports.ReadonlyError = exports.CancellationError = exports.errorHandler = exports.ErrorHandler = void 0;\nexports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;\nexports.isSigPipeError = isSigPipeError;\nexports.onUnexpectedError = onUnexpectedError;\nexports.onUnexpectedExternalError = onUnexpectedExternalError;\nexports.transformErrorForSerialization = transformErrorForSerialization;\nexports.transformErrorFromSerialization = transformErrorFromSerialization;\nexports.isCancellationError = isCancellationError;\nexports.canceled = canceled;\nexports.illegalArgument = illegalArgument;\nexports.illegalState = illegalState;\nexports.getErrorMessage = getErrorMessage;\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nclass ErrorHandler {\n    constructor() {\n        this.listeners = [];\n        this.unexpectedErrorHandler = function (e) {\n            setTimeout(() => {\n                if (e.stack) {\n                    if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n                        throw new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n                    }\n                    throw new Error(e.message + '\\n\\n' + e.stack);\n                }\n                throw e;\n            }, 0);\n        };\n    }\n    addListener(listener) {\n        this.listeners.push(listener);\n        return () => {\n            this._removeListener(listener);\n        };\n    }\n    emit(e) {\n        this.listeners.forEach((listener) => {\n            listener(e);\n        });\n    }\n    _removeListener(listener) {\n        this.listeners.splice(this.listeners.indexOf(listener), 1);\n    }\n    setUnexpectedErrorHandler(newUnexpectedErrorHandler) {\n        this.unexpectedErrorHandler = newUnexpectedErrorHandler;\n    }\n    getUnexpectedErrorHandler() {\n        return this.unexpectedErrorHandler;\n    }\n    onUnexpectedError(e) {\n        this.unexpectedErrorHandler(e);\n        this.emit(e);\n    }\n    // For external errors, we don't want the listeners to be called\n    onUnexpectedExternalError(e) {\n        this.unexpectedErrorHandler(e);\n    }\n}\nexports.ErrorHandler = ErrorHandler;\nexports.errorHandler = new ErrorHandler();\n/** @skipMangle */\nfunction setUnexpectedErrorHandler(newUnexpectedErrorHandler) {\n    exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n/**\n * Returns if the error is a SIGPIPE error. SIGPIPE errors should generally be\n * logged at most once, to avoid a loop.\n *\n * @see https://github.com/microsoft/vscode-remote-release/issues/6481\n */\nfunction isSigPipeError(e) {\n    if (!e || typeof e !== 'object') {\n        return false;\n    }\n    const cast = e;\n    return cast.code === 'EPIPE' && cast.syscall?.toUpperCase() === 'WRITE';\n}\nfunction onUnexpectedError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        exports.errorHandler.onUnexpectedError(e);\n    }\n    return undefined;\n}\nfunction onUnexpectedExternalError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        exports.errorHandler.onUnexpectedExternalError(e);\n    }\n    return undefined;\n}\nfunction transformErrorForSerialization(error) {\n    if (error instanceof Error) {\n        const { name, message } = error;\n        const stack = error.stacktrace || error.stack;\n        return {\n            $isError: true,\n            name,\n            message,\n            stack,\n            noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)\n        };\n    }\n    // return as is\n    return error;\n}\nfunction transformErrorFromSerialization(data) {\n    let error;\n    if (data.noTelemetry) {\n        error = new ErrorNoTelemetry();\n    }\n    else {\n        error = new Error();\n        error.name = data.name;\n    }\n    error.message = data.message;\n    error.stack = data.stack;\n    return error;\n}\nconst canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\nfunction isCancellationError(error) {\n    if (error instanceof CancellationError) {\n        return true;\n    }\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nclass CancellationError extends Error {\n    constructor() {\n        super(canceledName);\n        this.name = this.message;\n    }\n}\nexports.CancellationError = CancellationError;\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nfunction canceled() {\n    const error = new Error(canceledName);\n    error.name = error.message;\n    return error;\n}\nfunction illegalArgument(name) {\n    if (name) {\n        return new Error(`Illegal argument: ${name}`);\n    }\n    else {\n        return new Error('Illegal argument');\n    }\n}\nfunction illegalState(name) {\n    if (name) {\n        return new Error(`Illegal state: ${name}`);\n    }\n    else {\n        return new Error('Illegal state');\n    }\n}\nclass ReadonlyError extends TypeError {\n    constructor(name) {\n        super(name ? `${name} is read-only and cannot be changed` : 'Cannot change read-only property');\n    }\n}\nexports.ReadonlyError = ReadonlyError;\nfunction getErrorMessage(err) {\n    if (!err) {\n        return 'Error';\n    }\n    if (err.message) {\n        return err.message;\n    }\n    if (err.stack) {\n        return err.stack.split('\\n')[0];\n    }\n    return String(err);\n}\nclass NotImplementedError extends Error {\n    constructor(message) {\n        super('NotImplemented');\n        if (message) {\n            this.message = message;\n        }\n    }\n}\nexports.NotImplementedError = NotImplementedError;\nclass NotSupportedError extends Error {\n    constructor(message) {\n        super('NotSupported');\n        if (message) {\n            this.message = message;\n        }\n    }\n}\nexports.NotSupportedError = NotSupportedError;\nclass ExpectedError extends Error {\n    constructor() {\n        super(...arguments);\n        this.isExpected = true;\n    }\n}\nexports.ExpectedError = ExpectedError;\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nclass ErrorNoTelemetry extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'CodeExpectedError';\n    }\n    static fromError(err) {\n        if (err instanceof ErrorNoTelemetry) {\n            return err;\n        }\n        const result = new ErrorNoTelemetry();\n        result.message = err.message;\n        result.stack = err.stack;\n        return result;\n    }\n    static isErrorNoTelemetry(err) {\n        return err.name === 'CodeExpectedError';\n    }\n}\nexports.ErrorNoTelemetry = ErrorNoTelemetry;\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nclass BugIndicatingError extends Error {\n    constructor(message) {\n        super(message || 'An unexpected bug occurred.');\n        Object.setPrototypeOf(this, BugIndicatingError.prototype);\n        // Because we know for sure only buggy code throws this,\n        // we definitely want to break here and fix the bug.\n        // eslint-disable-next-line no-debugger\n        // debugger;\n    }\n}\nexports.BugIndicatingError = BugIndicatingError;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueWithChangeEvent = exports.Relay = exports.EventBufferer = exports.DynamicListEventMultiplexer = exports.EventMultiplexer = exports.MicrotaskEmitter = exports.DebounceEmitter = exports.PauseableEmitter = exports.AsyncEmitter = exports.createEventDeliveryQueue = exports.Emitter = exports.ListenerRefusalError = exports.ListenerLeakError = exports.EventProfiling = exports.Event = void 0;\nexports.setGlobalLeakWarningThreshold = setGlobalLeakWarningThreshold;\nconst errors_1 = require(\"vs/base/common/errors\");\nconst functional_1 = require(\"vs/base/common/functional\");\nconst lifecycle_1 = require(\"vs/base/common/lifecycle\");\nconst linkedList_1 = require(\"vs/base/common/linkedList\");\nconst stopwatch_1 = require(\"vs/base/common/stopwatch\");\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableListenerGCedWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nvar Event;\n(function (Event) {\n    Event.None = () => lifecycle_1.Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onDidAddListener: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onDidAddListener = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd?.();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n     * result of merging events and to try prevent race conditions that could arise when using related deferred and\n     * non-deferred events.\n     *\n     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n     * (eg. latency of keypress to text rendered).\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function defer(event, disposable) {\n        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n    }\n    Event.defer = defer;\n    /**\n     * Given an event, returns another event which only fires once.\n     *\n     * @param event The event source for the new event.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * Maps an event of one type into an event of another type using a mapping function, similar to how\n     * `Array.prototype.map` works.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param map The mapping function.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * Wraps an event in another event that performs some function on the event object before firing.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param each The function to perform on the event object.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => {\n            const disposable = (0, lifecycle_1.combinedDisposable)(...events.map(event => event(e => listener.call(thisArgs, e))));\n            return addAndReturnDisposable(disposable, disposables);\n        };\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onWillAddFirstListener() {\n                listener = event(emitter.fire, emitter);\n            },\n            onDidRemoveLastListener() {\n                listener?.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable?.add(emitter);\n        return emitter.event;\n    }\n    /**\n     * Adds the IDisposable to the store if it's set, and returns it. Useful to\n     * Event function implementation.\n     */\n    function addAndReturnDisposable(d, store) {\n        if (store instanceof Array) {\n            store.push(d);\n        }\n        else if (store) {\n            store.add(d);\n        }\n        return d;\n    }\n    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        let doFire;\n        const options = {\n            leakWarningThreshold,\n            onWillAddFirstListener() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    doFire = () => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    };\n                    if (typeof delay === 'number') {\n                        clearTimeout(handle);\n                        handle = setTimeout(doFire, delay);\n                    }\n                    else {\n                        if (handle === undefined) {\n                            handle = 0;\n                            queueMicrotask(doFire);\n                        }\n                    }\n                });\n            },\n            onWillRemoveListener() {\n                if (flushOnListenerRemove && numDebouncedCalls > 0) {\n                    doFire?.();\n                }\n            },\n            onDidRemoveLastListener() {\n                doFire = undefined;\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable?.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function accumulate(event, delay = 0, disposable) {\n        return Event.debounce(event, (last, e) => {\n            if (!last) {\n                return [e];\n            }\n            last.push(e);\n            return last;\n        }, delay, undefined, true, undefined, disposable);\n    }\n    Event.accumulate = accumulate;\n    /**\n     * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n     * event objects from different sources do not fire the same event object.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param equals The equality condition.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     *\n     * @example\n     * ```\n     * // Fire only one time when a single window is opened or focused\n     * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n     * ```\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @example\n     * ```\n     * const event = new EventEmitter<number | undefined>().event;\n     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n     * ```\n     *\n     * @param event The event source for the new event.\n     * @param isT A function that determines what event is of the first type.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * Buffers an event until it has a listener attached.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n     * `setTimeout` when the first event listener is added.\n     * @param _buffer Internal: A source event array used for tests.\n     *\n     * @example\n     * ```\n     * // Start accumulating events, when the first listener is attached, flush\n     * // the event after a timeout such that multiple listeners attached before\n     * // the timeout would receive the event\n     * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n     * ```\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        if (disposable) {\n            disposable.add(listener);\n        }\n        const flush = () => {\n            buffer?.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onWillAddFirstListener() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                    if (disposable) {\n                        disposable.add(listener);\n                    }\n                }\n            },\n            onDidAddFirstListener() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onDidRemoveLastListener() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        if (disposable) {\n            disposable.add(emitter);\n        }\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    /**\n     * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n     *\n     * @example\n     * ```\n     * // Normal\n     * const onEnterPressNormal = Event.filter(\n     *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n     *   e.keyCode === KeyCode.Enter\n     * ).event;\n     *\n     * // Using chain\n     * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n     *   .map(e => new StandardKeyboardEvent(e))\n     *   .filter(e => e.keyCode === KeyCode.Enter)\n     * );\n     * ```\n     */\n    function chain(event, sythensize) {\n        const fn = (listener, thisArgs, disposables) => {\n            const cs = sythensize(new ChainableSynthesis());\n            return event(function (value) {\n                const result = cs.evaluate(value);\n                if (result !== HaltChainable) {\n                    listener.call(thisArgs, result);\n                }\n            }, undefined, disposables);\n        };\n        return fn;\n    }\n    Event.chain = chain;\n    const HaltChainable = Symbol('HaltChainable');\n    class ChainableSynthesis {\n        constructor() {\n            this.steps = [];\n        }\n        map(fn) {\n            this.steps.push(fn);\n            return this;\n        }\n        forEach(fn) {\n            this.steps.push(v => {\n                fn(v);\n                return v;\n            });\n            return this;\n        }\n        filter(fn) {\n            this.steps.push(v => fn(v) ? v : HaltChainable);\n            return this;\n        }\n        reduce(merge, initial) {\n            let last = initial;\n            this.steps.push(v => {\n                last = merge(last, v);\n                return last;\n            });\n            return this;\n        }\n        latch(equals = (a, b) => a === b) {\n            let firstCall = true;\n            let cache;\n            this.steps.push(value => {\n                const shouldEmit = firstCall || !equals(value, cache);\n                firstCall = false;\n                cache = value;\n                return shouldEmit ? value : HaltChainable;\n            });\n            return this;\n        }\n        evaluate(value) {\n            for (const step of this.steps) {\n                value = step(value);\n                if (value === HaltChainable) {\n                    break;\n                }\n            }\n            return value;\n        }\n    }\n    /**\n     * Creates an {@link Event} from a node event emitter.\n     */\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    /**\n     * Creates an {@link Event} from a DOM event emitter.\n     */\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    /**\n     * Creates a promise out of an event, using the {@link Event.once} helper.\n     */\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    /**\n     * Creates an event out of a promise that fires once when the promise is\n     * resolved with the result of the promise or `undefined`.\n     */\n    function fromPromise(promise) {\n        const result = new Emitter();\n        promise.then(res => {\n            result.fire(res);\n        }, () => {\n            result.fire(undefined);\n        }).finally(() => {\n            result.dispose();\n        });\n        return result.event;\n    }\n    Event.fromPromise = fromPromise;\n    /**\n     * A convenience function for forwarding an event to another emitter which\n     * improves readability.allows Event.forward(event, emitter) instead of `event(e => emitter.fire(e))`.\n     * @param from The event to forward.\n     * @param to The emitter to forward the event to.\n     * @example\n     * Event.forward(event, emitter);\n     * // equivalent to\n     * event(e => emitter.fire(e));\n     * // equivalent to\n     * event(emitter.fire, emitter);\n     */\n    function forward(from, to) {\n        return from(e => to.fire(e));\n    }\n    Event.forward = forward;\n    function runAndSubscribe(event, handler, initial) {\n        handler(initial);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    class EmitterObserver {\n        constructor(_observable, store) {\n            this._observable = _observable;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onWillAddFirstListener: () => {\n                    _observable.addObserver(this);\n                },\n                onDidRemoveLastListener: () => {\n                    _observable.removeObserver(this);\n                }\n            };\n            if (!store) {\n                _addLeakageTraceLogic(options);\n            }\n            this.emitter = new Emitter(options);\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter++;\n        }\n        handlePossibleChange(_observable) {\n            // assert(_observable === this.obs);\n        }\n        handleChange(_observable, _change) {\n            // assert(_observable === this.obs);\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter--;\n            if (this._counter === 0) {\n                this._observable.reportChanges();\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this._observable.get());\n                }\n            }\n        }\n    }\n    /**\n     * Creates an event emitter that is fired when the observable changes.\n     * Each listeners subscribes to the emitter.\n     */\n    function fromObservable(obs, store) {\n        const observer = new EmitterObserver(obs, store);\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n    /**\n     * Each listener is attached to the observable directly.\n     */\n    function fromObservableLight(observable) {\n        return (listener, thisArgs, disposables) => {\n            let count = 0;\n            let didChange = false;\n            const observer = {\n                beginUpdate() {\n                    count++;\n                },\n                endUpdate() {\n                    count--;\n                    if (count === 0) {\n                        observable.reportChanges();\n                        if (didChange) {\n                            didChange = false;\n                            listener.call(thisArgs);\n                        }\n                    }\n                },\n                handlePossibleChange() {\n                    // noop\n                },\n                handleChange() {\n                    didChange = true;\n                }\n            };\n            observable.addObserver(observer);\n            observable.reportChanges();\n            const disposable = {\n                dispose() {\n                    observable.removeObserver(observer);\n                }\n            };\n            if (disposables instanceof lifecycle_1.DisposableStore) {\n                disposables.add(disposable);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(disposable);\n            }\n            return disposable;\n        };\n    }\n    Event.fromObservableLight = fromObservableLight;\n})(Event || (exports.Event = Event = {}));\nclass EventProfiling {\n    static { this.all = new Set(); }\n    static { this._idPool = 0; }\n    constructor(name) {\n        this.listenerCount = 0;\n        this.invocationCount = 0;\n        this.elapsedOverall = 0;\n        this.durations = [];\n        this.name = `${name}_${EventProfiling._idPool++}`;\n        EventProfiling.all.add(this);\n    }\n    start(listenerCount) {\n        this._stopWatch = new stopwatch_1.StopWatch();\n        this.listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this.durations.push(elapsed);\n            this.elapsedOverall += elapsed;\n            this.invocationCount += 1;\n            this._stopWatch = undefined;\n        }\n    }\n}\nexports.EventProfiling = EventProfiling;\nlet _globalLeakWarningThreshold = -1;\nfunction setGlobalLeakWarningThreshold(n) {\n    const oldValue = _globalLeakWarningThreshold;\n    _globalLeakWarningThreshold = n;\n    return {\n        dispose() {\n            _globalLeakWarningThreshold = oldValue;\n        }\n    };\n}\nclass LeakageMonitor {\n    static { this._idPool = 1; }\n    constructor(_errorHandler, threshold, name = (LeakageMonitor._idPool++).toString(16).padStart(3, '0')) {\n        this._errorHandler = _errorHandler;\n        this.threshold = threshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        this._stacks?.clear();\n    }\n    check(stack, listenerCount) {\n        const threshold = this.threshold;\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            const [topStack, topCount] = this.getMostFrequentStack();\n            const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n            console.warn(message);\n            console.warn(topStack);\n            const error = new ListenerLeakError(message, topStack);\n            this._errorHandler(error);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n    getMostFrequentStack() {\n        if (!this._stacks) {\n            return undefined;\n        }\n        let topStack;\n        let topCount = 0;\n        for (const [stack, count] of this._stacks) {\n            if (!topStack || topCount < count) {\n                topStack = [stack, count];\n                topCount = count;\n            }\n        }\n        return topStack;\n    }\n}\nclass Stacktrace {\n    static create() {\n        const err = new Error();\n        return new Stacktrace(err.stack ?? '');\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\n// error that is logged when going over the configured listener threshold\nclass ListenerLeakError extends Error {\n    constructor(message, stack) {\n        super(message);\n        this.name = 'ListenerLeakError';\n        this.stack = stack;\n    }\n}\nexports.ListenerLeakError = ListenerLeakError;\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nclass ListenerRefusalError extends Error {\n    constructor(message, stack) {\n        super(message);\n        this.name = 'ListenerRefusalError';\n        this.stack = stack;\n    }\n}\nexports.ListenerRefusalError = ListenerRefusalError;\nlet id = 0;\nclass UniqueContainer {\n    constructor(value) {\n        this.value = value;\n        this.id = id++;\n    }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n    if (listeners instanceof UniqueContainer) {\n        fn(listeners);\n    }\n    else {\n        for (let i = 0; i < listeners.length; i++) {\n            const l = listeners[i];\n            if (l) {\n                fn(l);\n            }\n        }\n    }\n};\nlet _listenerFinalizers;\nif (_enableListenerGCedWarning) {\n    const leaks = [];\n    setInterval(() => {\n        if (leaks.length === 0) {\n            return;\n        }\n        console.warn('[LEAKING LISTENERS] GC\\'ed these listeners that were NOT yet disposed:');\n        console.warn(leaks.join('\\n'));\n        leaks.length = 0;\n    }, 3000);\n    _listenerFinalizers = new FinalizationRegistry(heldValue => {\n        if (typeof heldValue === 'string') {\n            leaks.push(heldValue);\n        }\n    });\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nclass Emitter {\n    constructor(options) {\n        this._size = 0;\n        this._options = options;\n        this._leakageMon = (_globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold)\n            ? new LeakageMonitor(options?.onListenerError ?? errors_1.onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) :\n            undefined;\n        this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n        this._deliveryQueue = this._options?.deliveryQueue;\n    }\n    dispose() {\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (this._deliveryQueue?.current === this) {\n                this._deliveryQueue.reset();\n            }\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = this._listeners;\n                    queueMicrotask(() => {\n                        forEachListener(listeners, l => l.stack?.print());\n                    });\n                }\n                this._listeners = undefined;\n                this._size = 0;\n            }\n            this._options?.onDidRemoveLastListener?.();\n            this._leakageMon?.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        this._event ??= (callback, thisArgs, disposables) => {\n            if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n                const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n                console.warn(message);\n                const tuple = this._leakageMon.getMostFrequentStack() ?? ['UNKNOWN stack', -1];\n                const error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n                const errorHandler = this._options?.onListenerError || errors_1.onUnexpectedError;\n                errorHandler(error);\n                return lifecycle_1.Disposable.None;\n            }\n            if (this._disposed) {\n                // todo: should we warn if a listener is added to a disposed emitter? This happens often\n                return lifecycle_1.Disposable.None;\n            }\n            if (thisArgs) {\n                callback = callback.bind(thisArgs);\n            }\n            const contained = new UniqueContainer(callback);\n            let removeMonitor;\n            let stack;\n            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n                // check and record this emitter for potential leakage\n                contained.stack = Stacktrace.create();\n                removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n            }\n            if (_enableDisposeWithListenerWarning) {\n                contained.stack = stack ?? Stacktrace.create();\n            }\n            if (!this._listeners) {\n                this._options?.onWillAddFirstListener?.(this);\n                this._listeners = contained;\n                this._options?.onDidAddFirstListener?.(this);\n            }\n            else if (this._listeners instanceof UniqueContainer) {\n                this._deliveryQueue ??= new EventDeliveryQueuePrivate();\n                this._listeners = [this._listeners, contained];\n            }\n            else {\n                this._listeners.push(contained);\n            }\n            this._size++;\n            const result = (0, lifecycle_1.toDisposable)(() => {\n                _listenerFinalizers?.unregister(result);\n                removeMonitor?.();\n                this._removeListener(contained);\n            });\n            if (disposables instanceof lifecycle_1.DisposableStore) {\n                disposables.add(result);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(result);\n            }\n            if (_listenerFinalizers) {\n                const stack = new Error().stack.split('\\n').slice(2, 3).join('\\n').trim();\n                const match = /(file:|vscode-file:\\/\\/vscode-app)?(\\/[^:]*:\\d+:\\d+)/.exec(stack);\n                _listenerFinalizers.register(result, match?.[2] ?? stack, result);\n            }\n            return result;\n        };\n        return this._event;\n    }\n    _removeListener(listener) {\n        this._options?.onWillRemoveListener?.(this);\n        if (!this._listeners) {\n            return; // expected if a listener gets disposed\n        }\n        if (this._size === 1) {\n            this._listeners = undefined;\n            this._options?.onDidRemoveLastListener?.(this);\n            this._size = 0;\n            return;\n        }\n        // size > 1 which requires that listeners be a list:\n        const listeners = this._listeners;\n        const index = listeners.indexOf(listener);\n        if (index === -1) {\n            console.log('disposed?', this._disposed);\n            console.log('size?', this._size);\n            console.log('arr?', JSON.stringify(this._listeners));\n            throw new Error('Attempted to dispose unknown listener');\n        }\n        this._size--;\n        listeners[index] = undefined;\n        const adjustDeliveryQueue = this._deliveryQueue.current === this;\n        if (this._size * compactionThreshold <= listeners.length) {\n            let n = 0;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listeners[i]) {\n                    listeners[n++] = listeners[i];\n                }\n                else if (adjustDeliveryQueue) {\n                    this._deliveryQueue.end--;\n                    if (n < this._deliveryQueue.i) {\n                        this._deliveryQueue.i--;\n                    }\n                }\n            }\n            listeners.length = n;\n        }\n    }\n    _deliver(listener, value) {\n        if (!listener) {\n            return;\n        }\n        const errorHandler = this._options?.onListenerError || errors_1.onUnexpectedError;\n        if (!errorHandler) {\n            listener.value(value);\n            return;\n        }\n        try {\n            listener.value(value);\n        }\n        catch (e) {\n            errorHandler(e);\n        }\n    }\n    /** Delivers items in the queue. Assumes the queue is ready to go. */\n    _deliverQueue(dq) {\n        const listeners = dq.current._listeners;\n        while (dq.i < dq.end) {\n            // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n            this._deliver(listeners[dq.i++], dq.value);\n        }\n        dq.reset();\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._deliveryQueue?.current) {\n            this._deliverQueue(this._deliveryQueue);\n            this._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n        }\n        this._perfMon?.start(this._size);\n        if (!this._listeners) {\n            // no-op\n        }\n        else if (this._listeners instanceof UniqueContainer) {\n            this._deliver(this._listeners, event);\n        }\n        else {\n            const dq = this._deliveryQueue;\n            dq.enqueue(this, event, this._listeners.length);\n            this._deliverQueue(dq);\n        }\n        this._perfMon?.stop();\n    }\n    hasListeners() {\n        return this._size > 0;\n    }\n}\nexports.Emitter = Emitter;\nconst createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\nexports.createEventDeliveryQueue = createEventDeliveryQueue;\nclass EventDeliveryQueuePrivate {\n    constructor() {\n        /**\n         * Index in current's listener list.\n         */\n        this.i = -1;\n        /**\n         * The last index in the listener's list to deliver.\n         */\n        this.end = 0;\n    }\n    enqueue(emitter, value, end) {\n        this.i = 0;\n        this.end = end;\n        this.current = emitter;\n        this.value = value;\n    }\n    reset() {\n        this.i = this.end; // force any current emission loop to stop, mainly for during dispose\n        this.current = undefined;\n        this.value = undefined;\n    }\n}\nclass AsyncEmitter extends Emitter {\n    async fireAsync(data, token, promiseJoin) {\n        if (!this._listeners) {\n            return;\n        }\n        if (!this._asyncDeliveryQueue) {\n            this._asyncDeliveryQueue = new linkedList_1.LinkedList();\n        }\n        forEachListener(this._listeners, listener => this._asyncDeliveryQueue.push([listener.value, data]));\n        while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n            const [listener, data] = this._asyncDeliveryQueue.shift();\n            const thenables = [];\n            const event = {\n                ...data,\n                token,\n                waitUntil: (p) => {\n                    if (Object.isFrozen(thenables)) {\n                        throw new Error('waitUntil can NOT be called asynchronous');\n                    }\n                    if (promiseJoin) {\n                        p = promiseJoin(p, listener);\n                    }\n                    thenables.push(p);\n                }\n            };\n            try {\n                listener(event);\n            }\n            catch (e) {\n                (0, errors_1.onUnexpectedError)(e);\n                continue;\n            }\n            // freeze thenables-collection to enforce sync-calls to\n            // wait until and then wait for all thenables to resolve\n            Object.freeze(thenables);\n            await Promise.allSettled(thenables).then(values => {\n                for (const value of values) {\n                    if (value.status === 'rejected') {\n                        (0, errors_1.onUnexpectedError)(value.reason);\n                    }\n                }\n            });\n        }\n    }\n}\nexports.AsyncEmitter = AsyncEmitter;\nclass PauseableEmitter extends Emitter {\n    get isPaused() {\n        return this._isPaused !== 0;\n    }\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new linkedList_1.LinkedList();\n        this._mergeFn = options?.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                if (this._eventQueue.size > 0) {\n                    const events = Array.from(this._eventQueue);\n                    this._eventQueue.clear();\n                    super.fire(this._mergeFn(events));\n                }\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._size) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexports.PauseableEmitter = PauseableEmitter;\nclass DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        super(options);\n        this._delay = options.delay ?? 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\nexports.DebounceEmitter = DebounceEmitter;\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nclass MicrotaskEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._queuedEvents = [];\n        this._mergeFn = options?.merge;\n    }\n    fire(event) {\n        if (!this.hasListeners()) {\n            return;\n        }\n        this._queuedEvents.push(event);\n        if (this._queuedEvents.length === 1) {\n            queueMicrotask(() => {\n                if (this._mergeFn) {\n                    super.fire(this._mergeFn(this._queuedEvents));\n                }\n                else {\n                    this._queuedEvents.forEach(e => super.fire(e));\n                }\n                this._queuedEvents = [];\n            });\n        }\n    }\n}\nexports.MicrotaskEmitter = MicrotaskEmitter;\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nclass EventMultiplexer {\n    constructor() {\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = new Emitter({\n            onWillAddFirstListener: () => this.onFirstListenerAdd(),\n            onDidRemoveLastListener: () => this.onLastListenerRemove()\n        });\n    }\n    get event() {\n        return this.emitter.event;\n    }\n    add(event) {\n        const e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        const dispose = () => {\n            if (this.hasListeners) {\n                this.unhook(e);\n            }\n            const idx = this.events.indexOf(e);\n            this.events.splice(idx, 1);\n        };\n        return (0, lifecycle_1.toDisposable)((0, functional_1.createSingleCallFunction)(dispose));\n    }\n    onFirstListenerAdd() {\n        this.hasListeners = true;\n        this.events.forEach(e => this.hook(e));\n    }\n    onLastListenerRemove() {\n        this.hasListeners = false;\n        this.events.forEach(e => this.unhook(e));\n    }\n    hook(e) {\n        e.listener = e.event(r => this.emitter.fire(r));\n    }\n    unhook(e) {\n        e.listener?.dispose();\n        e.listener = null;\n    }\n    dispose() {\n        this.emitter.dispose();\n        for (const e of this.events) {\n            e.listener?.dispose();\n        }\n        this.events = [];\n    }\n}\nexports.EventMultiplexer = EventMultiplexer;\nclass DynamicListEventMultiplexer {\n    constructor(items, onAddItem, onRemoveItem, getEvent) {\n        this._store = new lifecycle_1.DisposableStore();\n        const multiplexer = this._store.add(new EventMultiplexer());\n        const itemListeners = this._store.add(new lifecycle_1.DisposableMap());\n        function addItem(instance) {\n            itemListeners.set(instance, multiplexer.add(getEvent(instance)));\n        }\n        // Existing items\n        for (const instance of items) {\n            addItem(instance);\n        }\n        // Added items\n        this._store.add(onAddItem(instance => {\n            addItem(instance);\n        }));\n        // Removed items\n        this._store.add(onRemoveItem(instance => {\n            itemListeners.deleteAndDispose(instance);\n        }));\n        this.event = multiplexer.event;\n    }\n    dispose() {\n        this._store.dispose();\n    }\n}\nexports.DynamicListEventMultiplexer = DynamicListEventMultiplexer;\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nclass EventBufferer {\n    constructor() {\n        this.data = [];\n    }\n    wrapEvent(event, reduce, initial) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const data = this.data[this.data.length - 1];\n                // Non-reduce scenario\n                if (!reduce) {\n                    // Buffering case\n                    if (data) {\n                        data.buffers.push(() => listener.call(thisArgs, i));\n                    }\n                    else {\n                        // Not buffering case\n                        listener.call(thisArgs, i);\n                    }\n                    return;\n                }\n                // Reduce scenario\n                const reduceData = data;\n                // Not buffering case\n                if (!reduceData) {\n                    // TODO: Is there a way to cache this reduce call for all listeners?\n                    listener.call(thisArgs, reduce(initial, i));\n                    return;\n                }\n                // Buffering case\n                reduceData.items ??= [];\n                reduceData.items.push(i);\n                if (reduceData.buffers.length === 0) {\n                    // Include a single buffered function that will reduce all events when we're done buffering events\n                    data.buffers.push(() => {\n                        // cache the reduced result so that the value can be shared across all listeners\n                        reduceData.reducedResult ??= initial\n                            ? reduceData.items.reduce(reduce, initial)\n                            : reduceData.items.reduce(reduce);\n                        listener.call(thisArgs, reduceData.reducedResult);\n                    });\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const data = { buffers: new Array() };\n        this.data.push(data);\n        const r = fn();\n        this.data.pop();\n        data.buffers.forEach(flush => flush());\n        return r;\n    }\n}\nexports.EventBufferer = EventBufferer;\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nclass Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = lifecycle_1.Disposable.None;\n        this.emitter = new Emitter({\n            onDidAddFirstListener: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onDidRemoveLastListener: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\nexports.Relay = Relay;\nclass ValueWithChangeEvent {\n    static const(value) {\n        return new ConstValueWithChangeEvent(value);\n    }\n    constructor(_value) {\n        this._value = _value;\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        if (value !== this._value) {\n            this._value = value;\n            this._onDidChange.fire(undefined);\n        }\n    }\n}\nexports.ValueWithChangeEvent = ValueWithChangeEvent;\nclass ConstValueWithChangeEvent {\n    constructor(value) {\n        this.value = value;\n        this.onDidChange = Event.None;\n    }\n}\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createSingleCallFunction = createSingleCallFunction;\n/**\n * Given a function, returns a function that is only calling that function once.\n */\nfunction createSingleCallFunction(fn, fnDidRunCallback) {\n    const _this = this;\n    let didCall = false;\n    let result;\n    return function () {\n        if (didCall) {\n            return result;\n        }\n        didCall = true;\n        if (fnDidRunCallback) {\n            try {\n                result = fn.apply(_this, arguments);\n            }\n            finally {\n                fnDidRunCallback();\n            }\n        }\n        else {\n            result = fn.apply(_this, arguments);\n        }\n        return result;\n    };\n}\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Iterable = void 0;\nvar Iterable;\n(function (Iterable) {\n    function is(thing) {\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n    }\n    Iterable.is = is;\n    const _empty = Object.freeze([]);\n    function empty() {\n        return _empty;\n    }\n    Iterable.empty = empty;\n    function* single(element) {\n        yield element;\n    }\n    Iterable.single = single;\n    function wrap(iterableOrElement) {\n        if (is(iterableOrElement)) {\n            return iterableOrElement;\n        }\n        else {\n            return single(iterableOrElement);\n        }\n    }\n    Iterable.wrap = wrap;\n    function from(iterable) {\n        return iterable || _empty;\n    }\n    Iterable.from = from;\n    function* reverse(array) {\n        for (let i = array.length - 1; i >= 0; i--) {\n            yield array[i];\n        }\n    }\n    Iterable.reverse = reverse;\n    function isEmpty(iterable) {\n        return !iterable || iterable[Symbol.iterator]().next().done === true;\n    }\n    Iterable.isEmpty = isEmpty;\n    function first(iterable) {\n        return iterable[Symbol.iterator]().next().value;\n    }\n    Iterable.first = first;\n    function some(iterable, predicate) {\n        let i = 0;\n        for (const element of iterable) {\n            if (predicate(element, i++)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Iterable.some = some;\n    function find(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return undefined;\n    }\n    Iterable.find = find;\n    function* filter(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                yield element;\n            }\n        }\n    }\n    Iterable.filter = filter;\n    function* map(iterable, fn) {\n        let index = 0;\n        for (const element of iterable) {\n            yield fn(element, index++);\n        }\n    }\n    Iterable.map = map;\n    function* flatMap(iterable, fn) {\n        let index = 0;\n        for (const element of iterable) {\n            yield* fn(element, index++);\n        }\n    }\n    Iterable.flatMap = flatMap;\n    function* concat(...iterables) {\n        for (const iterable of iterables) {\n            yield* iterable;\n        }\n    }\n    Iterable.concat = concat;\n    function reduce(iterable, reducer, initialValue) {\n        let value = initialValue;\n        for (const element of iterable) {\n            value = reducer(value, element);\n        }\n        return value;\n    }\n    Iterable.reduce = reduce;\n    /**\n     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n     */\n    function* slice(arr, from, to = arr.length) {\n        if (from < 0) {\n            from += arr.length;\n        }\n        if (to < 0) {\n            to += arr.length;\n        }\n        else if (to > arr.length) {\n            to = arr.length;\n        }\n        for (; from < to; from++) {\n            yield arr[from];\n        }\n    }\n    Iterable.slice = slice;\n    /**\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\n     * and an iterable for the rest of the elements.\n     */\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n        const consumed = [];\n        if (atMost === 0) {\n            return [consumed, iterable];\n        }\n        const iterator = iterable[Symbol.iterator]();\n        for (let i = 0; i < atMost; i++) {\n            const next = iterator.next();\n            if (next.done) {\n                return [consumed, Iterable.empty()];\n            }\n            consumed.push(next.value);\n        }\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\n    }\n    Iterable.consume = consume;\n    async function asyncToArray(iterable) {\n        const result = [];\n        for await (const item of iterable) {\n            result.push(item);\n        }\n        return Promise.resolve(result);\n    }\n    Iterable.asyncToArray = asyncToArray;\n})(Iterable || (exports.Iterable = Iterable = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lazy = void 0;\nclass Lazy {\n    constructor(executor) {\n        this.executor = executor;\n        this._didRun = false;\n    }\n    /**\n     * True if the lazy value has been resolved.\n     */\n    get hasValue() { return this._didRun; }\n    /**\n     * Get the wrapped value.\n     *\n     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n     */\n    get value() {\n        if (!this._didRun) {\n            try {\n                this._value = this.executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n    /**\n     * Get the wrapped value without forcing evaluation.\n     */\n    get rawValue() { return this._value; }\n}\nexports.Lazy = Lazy;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DisposableMap = exports.ImmortalReference = exports.AsyncReferenceCollection = exports.ReferenceCollection = exports.SafeDisposable = exports.RefCountedDisposable = exports.MandatoryMutableDisposable = exports.MutableDisposable = exports.Disposable = exports.DisposableStore = exports.DisposableTracker = void 0;\nexports.setDisposableTracker = setDisposableTracker;\nexports.trackDisposable = trackDisposable;\nexports.markAsDisposed = markAsDisposed;\nexports.markAsSingleton = markAsSingleton;\nexports.isDisposable = isDisposable;\nexports.dispose = dispose;\nexports.disposeIfDisposable = disposeIfDisposable;\nexports.combinedDisposable = combinedDisposable;\nexports.toDisposable = toDisposable;\nexports.disposeOnReturn = disposeOnReturn;\nconst arrays_1 = require(\"vs/base/common/arrays\");\nconst collections_1 = require(\"vs/base/common/collections\");\nconst map_1 = require(\"./map\");\nconst functional_1 = require(\"vs/base/common/functional\");\nconst iterator_1 = require(\"vs/base/common/iterator\");\n// #region Disposable Tracking\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nclass DisposableTracker {\n    constructor() {\n        this.livingDisposables = new Map();\n    }\n    static { this.idx = 0; }\n    getDisposableData(d) {\n        let val = this.livingDisposables.get(d);\n        if (!val) {\n            val = { parent: null, source: null, isSingleton: false, value: d, idx: DisposableTracker.idx++ };\n            this.livingDisposables.set(d, val);\n        }\n        return val;\n    }\n    trackDisposable(d) {\n        const data = this.getDisposableData(d);\n        if (!data.source) {\n            data.source =\n                new Error().stack;\n        }\n    }\n    setParent(child, parent) {\n        const data = this.getDisposableData(child);\n        data.parent = parent;\n    }\n    markAsDisposed(x) {\n        this.livingDisposables.delete(x);\n    }\n    markAsSingleton(disposable) {\n        this.getDisposableData(disposable).isSingleton = true;\n    }\n    getRootParent(data, cache) {\n        const cacheValue = cache.get(data);\n        if (cacheValue) {\n            return cacheValue;\n        }\n        const result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;\n        cache.set(data, result);\n        return result;\n    }\n    getTrackedDisposables() {\n        const rootParentCache = new Map();\n        const leaking = [...this.livingDisposables.entries()]\n            .filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton)\n            .flatMap(([k]) => k);\n        return leaking;\n    }\n    computeLeakingDisposables(maxReported = 10, preComputedLeaks) {\n        let uncoveredLeakingObjs;\n        if (preComputedLeaks) {\n            uncoveredLeakingObjs = preComputedLeaks;\n        }\n        else {\n            const rootParentCache = new Map();\n            const leakingObjects = [...this.livingDisposables.values()]\n                .filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);\n            if (leakingObjects.length === 0) {\n                return;\n            }\n            const leakingObjsSet = new Set(leakingObjects.map(o => o.value));\n            // Remove all objects that are a child of other leaking objects. Assumes there are no cycles.\n            uncoveredLeakingObjs = leakingObjects.filter(l => {\n                return !(l.parent && leakingObjsSet.has(l.parent));\n            });\n            if (uncoveredLeakingObjs.length === 0) {\n                throw new Error('There are cyclic diposable chains!');\n            }\n        }\n        if (!uncoveredLeakingObjs) {\n            return undefined;\n        }\n        function getStackTracePath(leaking) {\n            function removePrefix(array, linesToRemove) {\n                while (array.length > 0 && linesToRemove.some(regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp))) {\n                    array.shift();\n                }\n            }\n            const lines = leaking.source.split('\\n').map(p => p.trim().replace('at ', '')).filter(l => l !== '');\n            removePrefix(lines, ['Error', /^trackDisposable \\(.*\\)$/, /^DisposableTracker.trackDisposable \\(.*\\)$/]);\n            return lines.reverse();\n        }\n        const stackTraceStarts = new map_1.SetMap();\n        for (const leaking of uncoveredLeakingObjs) {\n            const stackTracePath = getStackTracePath(leaking);\n            for (let i = 0; i <= stackTracePath.length; i++) {\n                stackTraceStarts.add(stackTracePath.slice(0, i).join('\\n'), leaking);\n            }\n        }\n        // Put earlier leaks first\n        uncoveredLeakingObjs.sort((0, arrays_1.compareBy)(l => l.idx, arrays_1.numberComparator));\n        let message = '';\n        let i = 0;\n        for (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n            i++;\n            const stackTracePath = getStackTracePath(leaking);\n            const stackTraceFormattedLines = [];\n            for (let i = 0; i < stackTracePath.length; i++) {\n                let line = stackTracePath[i];\n                const starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\\n'));\n                line = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n                const prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\\n'));\n                const continuations = (0, collections_1.groupBy)([...prevStarts].map(d => getStackTracePath(d)[i]), v => v);\n                delete continuations[stackTracePath[i]];\n                for (const [cont, set] of Object.entries(continuations)) {\n                    stackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);\n                }\n                stackTraceFormattedLines.unshift(line);\n            }\n            message += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join('\\n')}\\n============================================================\\n\\n`;\n        }\n        if (uncoveredLeakingObjs.length > maxReported) {\n            message += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n        }\n        return { leaks: uncoveredLeakingObjs, details: message };\n    }\n}\nexports.DisposableTracker = DisposableTracker;\nfunction setDisposableTracker(tracker) {\n    disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\n    setDisposableTracker(new class {\n        trackDisposable(x) {\n            const stack = new Error('Potentially leaked disposable').stack;\n            setTimeout(() => {\n                if (!x[__is_disposable_tracked__]) {\n                    console.log(stack);\n                }\n            }, 3000);\n        }\n        setParent(child, parent) {\n            if (child && child !== Disposable.None) {\n                try {\n                    child[__is_disposable_tracked__] = true;\n                }\n                catch {\n                    // noop\n                }\n            }\n        }\n        markAsDisposed(disposable) {\n            if (disposable && disposable !== Disposable.None) {\n                try {\n                    disposable[__is_disposable_tracked__] = true;\n                }\n                catch {\n                    // noop\n                }\n            }\n        }\n        markAsSingleton(disposable) { }\n    });\n}\nfunction trackDisposable(x) {\n    disposableTracker?.trackDisposable(x);\n    return x;\n}\nfunction markAsDisposed(disposable) {\n    disposableTracker?.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n    disposableTracker?.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n    if (!disposableTracker) {\n        return;\n    }\n    for (const child of children) {\n        disposableTracker.setParent(child, parent);\n    }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nfunction markAsSingleton(singleton) {\n    disposableTracker?.markAsSingleton(singleton);\n    return singleton;\n}\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nfunction isDisposable(thing) {\n    return typeof thing === 'object' && thing !== null && typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nfunction dispose(arg) {\n    if (iterator_1.Iterable.is(arg)) {\n        const errors = [];\n        for (const d of arg) {\n            if (d) {\n                try {\n                    d.dispose();\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        else if (errors.length > 1) {\n            throw new AggregateError(errors, 'Encountered errors while disposing of store');\n        }\n        return Array.isArray(arg) ? [] : arg;\n    }\n    else if (arg) {\n        arg.dispose();\n        return arg;\n    }\n}\nfunction disposeIfDisposable(disposables) {\n    for (const d of disposables) {\n        if (isDisposable(d)) {\n            d.dispose();\n        }\n    }\n    return [];\n}\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nfunction combinedDisposable(...disposables) {\n    const parent = toDisposable(() => dispose(disposables));\n    setParentOfDisposables(disposables, parent);\n    return parent;\n}\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nfunction toDisposable(fn) {\n    const self = trackDisposable({\n        dispose: (0, functional_1.createSingleCallFunction)(() => {\n            markAsDisposed(self);\n            fn();\n        })\n    });\n    return self;\n}\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nclass DisposableStore {\n    static { this.DISABLE_DISPOSED_WARNING = false; }\n    constructor() {\n        this._toDispose = new Set();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Dispose of all registered disposables and mark this object as disposed.\n     *\n     * Any future disposables added to this object will be disposed of on `add`.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clear();\n    }\n    /**\n     * @return `true` if this object has been disposed of.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of all registered disposables but do not mark this object as disposed.\n     */\n    clear() {\n        if (this._toDispose.size === 0) {\n            return;\n        }\n        try {\n            dispose(this._toDispose);\n        }\n        finally {\n            this._toDispose.clear();\n        }\n    }\n    /**\n     * Add a new {@link IDisposable disposable} to the collection.\n     */\n    add(o) {\n        if (!o) {\n            return o;\n        }\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        setParentOfDisposable(o, this);\n        if (this._isDisposed) {\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n            }\n        }\n        else {\n            this._toDispose.add(o);\n        }\n        return o;\n    }\n    /**\n     * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the\n     * disposable even when the disposable is not part in the store.\n     */\n    delete(o) {\n        if (!o) {\n            return;\n        }\n        if (o === this) {\n            throw new Error('Cannot dispose a disposable on itself!');\n        }\n        this._toDispose.delete(o);\n        o.dispose();\n    }\n    /**\n     * Deletes the value from the store, but does not dispose it.\n     */\n    deleteAndLeak(o) {\n        if (!o) {\n            return;\n        }\n        if (this._toDispose.has(o)) {\n            this._toDispose.delete(o);\n            setParentOfDisposable(o, null);\n        }\n    }\n}\nexports.DisposableStore = DisposableStore;\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nclass Disposable {\n    /**\n     * A disposable that does nothing when it is disposed of.\n     *\n     * TODO: This should not be a static property.\n     */\n    static { this.None = Object.freeze({ dispose() { } }); }\n    constructor() {\n        this._store = new DisposableStore();\n        trackDisposable(this);\n        setParentOfDisposable(this._store, this);\n    }\n    dispose() {\n        markAsDisposed(this);\n        this._store.dispose();\n    }\n    /**\n     * Adds `o` to the collection of disposables managed by this object.\n     */\n    _register(o) {\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        return this._store.add(o);\n    }\n}\nexports.Disposable = Disposable;\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nclass MutableDisposable {\n    constructor() {\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    get value() {\n        return this._isDisposed ? undefined : this._value;\n    }\n    set value(value) {\n        if (this._isDisposed || value === this._value) {\n            return;\n        }\n        this._value?.dispose();\n        if (value) {\n            setParentOfDisposable(value, this);\n        }\n        this._value = value;\n    }\n    /**\n     * Resets the stored value and disposed of the previously stored value.\n     */\n    clear() {\n        this.value = undefined;\n    }\n    dispose() {\n        this._isDisposed = true;\n        markAsDisposed(this);\n        this._value?.dispose();\n        this._value = undefined;\n    }\n    /**\n     * Clears the value, but does not dispose it.\n     * The old value is returned.\n    */\n    clearAndLeak() {\n        const oldValue = this._value;\n        this._value = undefined;\n        if (oldValue) {\n            setParentOfDisposable(oldValue, null);\n        }\n        return oldValue;\n    }\n}\nexports.MutableDisposable = MutableDisposable;\n/**\n * Manages the lifecycle of a disposable value that may be changed like {@link MutableDisposable}, but the value must\n * exist and cannot be undefined.\n */\nclass MandatoryMutableDisposable {\n    constructor(initialValue) {\n        this._disposable = new MutableDisposable();\n        this._isDisposed = false;\n        this._disposable.value = initialValue;\n    }\n    get value() {\n        return this._disposable.value;\n    }\n    set value(value) {\n        if (this._isDisposed || value === this._disposable.value) {\n            return;\n        }\n        this._disposable.value = value;\n    }\n    dispose() {\n        this._isDisposed = true;\n        this._disposable.dispose();\n    }\n}\nexports.MandatoryMutableDisposable = MandatoryMutableDisposable;\nclass RefCountedDisposable {\n    constructor(_disposable) {\n        this._disposable = _disposable;\n        this._counter = 1;\n    }\n    acquire() {\n        this._counter++;\n        return this;\n    }\n    release() {\n        if (--this._counter === 0) {\n            this._disposable.dispose();\n        }\n        return this;\n    }\n}\nexports.RefCountedDisposable = RefCountedDisposable;\n/**\n * A safe disposable can be `unset` so that a leaked reference (listener)\n * can be cut-off.\n */\nclass SafeDisposable {\n    constructor() {\n        this.dispose = () => { };\n        this.unset = () => { };\n        this.isset = () => false;\n        trackDisposable(this);\n    }\n    set(fn) {\n        let callback = fn;\n        this.unset = () => callback = undefined;\n        this.isset = () => callback !== undefined;\n        this.dispose = () => {\n            if (callback) {\n                callback();\n                callback = undefined;\n                markAsDisposed(this);\n            }\n        };\n        return this;\n    }\n}\nexports.SafeDisposable = SafeDisposable;\nclass ReferenceCollection {\n    constructor() {\n        this.references = new Map();\n    }\n    acquire(key, ...args) {\n        let reference = this.references.get(key);\n        if (!reference) {\n            reference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n            this.references.set(key, reference);\n        }\n        const { object } = reference;\n        const dispose = (0, functional_1.createSingleCallFunction)(() => {\n            if (--reference.counter === 0) {\n                this.destroyReferencedObject(key, reference.object);\n                this.references.delete(key);\n            }\n        });\n        reference.counter++;\n        return { object, dispose };\n    }\n}\nexports.ReferenceCollection = ReferenceCollection;\n/**\n * Unwraps a reference collection of promised values. Makes sure\n * references are disposed whenever promises get rejected.\n */\nclass AsyncReferenceCollection {\n    constructor(referenceCollection) {\n        this.referenceCollection = referenceCollection;\n    }\n    async acquire(key, ...args) {\n        const ref = this.referenceCollection.acquire(key, ...args);\n        try {\n            const object = await ref.object;\n            return {\n                object,\n                dispose: () => ref.dispose()\n            };\n        }\n        catch (error) {\n            ref.dispose();\n            throw error;\n        }\n    }\n}\nexports.AsyncReferenceCollection = AsyncReferenceCollection;\nclass ImmortalReference {\n    constructor(object) {\n        this.object = object;\n    }\n    dispose() { }\n}\nexports.ImmortalReference = ImmortalReference;\nfunction disposeOnReturn(fn) {\n    const store = new DisposableStore();\n    try {\n        fn(store);\n    }\n    finally {\n        store.dispose();\n    }\n}\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nclass DisposableMap {\n    constructor() {\n        this._store = new Map();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Disposes of all stored values and mark this object as disposed.\n     *\n     * Trying to use this object after it has been disposed of is an error.\n     */\n    dispose() {\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clearAndDisposeAll();\n    }\n    /**\n     * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n     */\n    clearAndDisposeAll() {\n        if (!this._store.size) {\n            return;\n        }\n        try {\n            dispose(this._store.values());\n        }\n        finally {\n            this._store.clear();\n        }\n    }\n    has(key) {\n        return this._store.has(key);\n    }\n    get size() {\n        return this._store.size;\n    }\n    get(key) {\n        return this._store.get(key);\n    }\n    set(key, value, skipDisposeOnOverwrite = false) {\n        if (this._isDisposed) {\n            console.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n        }\n        if (!skipDisposeOnOverwrite) {\n            this._store.get(key)?.dispose();\n        }\n        this._store.set(key, value);\n    }\n    /**\n     * Delete the value stored for `key` from this map and also dispose of it.\n     */\n    deleteAndDispose(key) {\n        this._store.get(key)?.dispose();\n        this._store.delete(key);\n    }\n    /**\n     * Delete the value stored for `key` from this map but return it. The caller is\n     * responsible for disposing of the value.\n     */\n    deleteAndLeak(key) {\n        const value = this._store.get(key);\n        this._store.delete(key);\n        return value;\n    }\n    keys() {\n        return this._store.keys();\n    }\n    values() {\n        return this._store.values();\n    }\n    [Symbol.iterator]() {\n        return this._store[Symbol.iterator]();\n    }\n}\nexports.DisposableMap = DisposableMap;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinkedList = void 0;\nclass Node {\n    static { this.Undefined = new Node(undefined); }\n    constructor(element) {\n        this.element = element;\n        this.next = Node.Undefined;\n        this.prev = Node.Undefined;\n    }\n}\nclass LinkedList {\n    constructor() {\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    get size() {\n        return this._size;\n    }\n    isEmpty() {\n        return this._first === Node.Undefined;\n    }\n    clear() {\n        let node = this._first;\n        while (node !== Node.Undefined) {\n            const next = node.next;\n            node.prev = Node.Undefined;\n            node.next = Node.Undefined;\n            node = next;\n        }\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    unshift(element) {\n        return this._insert(element, false);\n    }\n    push(element) {\n        return this._insert(element, true);\n    }\n    _insert(element, atTheEnd) {\n        const newNode = new Node(element);\n        if (this._first === Node.Undefined) {\n            this._first = newNode;\n            this._last = newNode;\n        }\n        else if (atTheEnd) {\n            // push\n            const oldLast = this._last;\n            this._last = newNode;\n            newNode.prev = oldLast;\n            oldLast.next = newNode;\n        }\n        else {\n            // unshift\n            const oldFirst = this._first;\n            this._first = newNode;\n            newNode.next = oldFirst;\n            oldFirst.prev = newNode;\n        }\n        this._size += 1;\n        let didRemove = false;\n        return () => {\n            if (!didRemove) {\n                didRemove = true;\n                this._remove(newNode);\n            }\n        };\n    }\n    shift() {\n        if (this._first === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._first.element;\n            this._remove(this._first);\n            return res;\n        }\n    }\n    pop() {\n        if (this._last === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._last.element;\n            this._remove(this._last);\n            return res;\n        }\n    }\n    _remove(node) {\n        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n            // middle\n            const anchor = node.prev;\n            anchor.next = node.next;\n            node.next.prev = anchor;\n        }\n        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n            // only node\n            this._first = Node.Undefined;\n            this._last = Node.Undefined;\n        }\n        else if (node.next === Node.Undefined) {\n            // last\n            this._last = this._last.prev;\n            this._last.next = Node.Undefined;\n        }\n        else if (node.prev === Node.Undefined) {\n            // first\n            this._first = this._first.next;\n            this._first.prev = Node.Undefined;\n        }\n        // done\n        this._size -= 1;\n    }\n    *[Symbol.iterator]() {\n        let node = this._first;\n        while (node !== Node.Undefined) {\n            yield node.element;\n            node = node.next;\n        }\n    }\n}\nexports.LinkedList = LinkedList;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetMap = exports.BidirectionalMap = exports.CounterSet = exports.Touch = void 0;\nexports.getOrSet = getOrSet;\nexports.mapToString = mapToString;\nexports.setToString = setToString;\nexports.mapsStrictEqualIgnoreOrder = mapsStrictEqualIgnoreOrder;\nfunction getOrSet(map, key, value) {\n    let result = map.get(key);\n    if (result === undefined) {\n        result = value;\n        map.set(key, result);\n    }\n    return result;\n}\nfunction mapToString(map) {\n    const entries = [];\n    map.forEach((value, key) => {\n        entries.push(`${key} => ${value}`);\n    });\n    return `Map(${map.size}) {${entries.join(', ')}}`;\n}\nfunction setToString(set) {\n    const entries = [];\n    set.forEach(value => {\n        entries.push(value);\n    });\n    return `Set(${set.size}) {${entries.join(', ')}}`;\n}\nvar Touch;\n(function (Touch) {\n    Touch[Touch[\"None\"] = 0] = \"None\";\n    Touch[Touch[\"AsOld\"] = 1] = \"AsOld\";\n    Touch[Touch[\"AsNew\"] = 2] = \"AsNew\";\n})(Touch || (exports.Touch = Touch = {}));\nclass CounterSet {\n    constructor() {\n        this.map = new Map();\n    }\n    add(value) {\n        this.map.set(value, (this.map.get(value) || 0) + 1);\n        return this;\n    }\n    delete(value) {\n        let counter = this.map.get(value) || 0;\n        if (counter === 0) {\n            return false;\n        }\n        counter--;\n        if (counter === 0) {\n            this.map.delete(value);\n        }\n        else {\n            this.map.set(value, counter);\n        }\n        return true;\n    }\n    has(value) {\n        return this.map.has(value);\n    }\n}\nexports.CounterSet = CounterSet;\n/**\n * A map that allows access both by keys and values.\n * **NOTE**: values need to be unique.\n */\nclass BidirectionalMap {\n    constructor(entries) {\n        this._m1 = new Map();\n        this._m2 = new Map();\n        if (entries) {\n            for (const [key, value] of entries) {\n                this.set(key, value);\n            }\n        }\n    }\n    clear() {\n        this._m1.clear();\n        this._m2.clear();\n    }\n    set(key, value) {\n        this._m1.set(key, value);\n        this._m2.set(value, key);\n    }\n    get(key) {\n        return this._m1.get(key);\n    }\n    getKey(value) {\n        return this._m2.get(value);\n    }\n    delete(key) {\n        const value = this._m1.get(key);\n        if (value === undefined) {\n            return false;\n        }\n        this._m1.delete(key);\n        this._m2.delete(value);\n        return true;\n    }\n    forEach(callbackfn, thisArg) {\n        this._m1.forEach((value, key) => {\n            callbackfn.call(thisArg, value, key, this);\n        });\n    }\n    keys() {\n        return this._m1.keys();\n    }\n    values() {\n        return this._m1.values();\n    }\n}\nexports.BidirectionalMap = BidirectionalMap;\nclass SetMap {\n    constructor() {\n        this.map = new Map();\n    }\n    add(key, value) {\n        let values = this.map.get(key);\n        if (!values) {\n            values = new Set();\n            this.map.set(key, values);\n        }\n        values.add(value);\n    }\n    delete(key, value) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.delete(value);\n        if (values.size === 0) {\n            this.map.delete(key);\n        }\n    }\n    forEach(key, fn) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.forEach(fn);\n    }\n    get(key) {\n        const values = this.map.get(key);\n        if (!values) {\n            return new Set();\n        }\n        return values;\n    }\n}\nexports.SetMap = SetMap;\nfunction mapsStrictEqualIgnoreOrder(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, value] of a) {\n        if (!b.has(key) || b.get(key) !== value) {\n            return false;\n        }\n    }\n    for (const [key] of b) {\n        if (!a.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isAndroid = exports.isEdge = exports.isSafari = exports.isFirefox = exports.isChrome = exports.OS = exports.OperatingSystem = exports.setTimeout0 = exports.setTimeout0IsFaster = exports.translationsConfigFile = exports.platformLocale = exports.locale = exports.Language = exports.language = exports.userAgent = exports.platform = exports.isCI = exports.isMobile = exports.isIOS = exports.webWorkerOrigin = exports.isWebWorker = exports.isWeb = exports.isElectron = exports.isNative = exports.isLinuxSnap = exports.isLinux = exports.isMacintosh = exports.isWindows = exports.Platform = exports.LANGUAGE_DEFAULT = void 0;\nexports.PlatformToString = PlatformToString;\nexports.isLittleEndian = isLittleEndian;\nexports.isBigSurOrNewer = isBigSurOrNewer;\nexports.LANGUAGE_DEFAULT = 'en';\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isLinuxSnap = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isElectron = false;\nlet _isIOS = false;\nlet _isCI = false;\nlet _isMobile = false;\nlet _locale = undefined;\nlet _language = exports.LANGUAGE_DEFAULT;\nlet _platformLocale = exports.LANGUAGE_DEFAULT;\nlet _translationsConfigFile = undefined;\nlet _userAgent = undefined;\nconst $globalThis = globalThis;\nlet nodeProcess = undefined;\nif (typeof $globalThis.vscode !== 'undefined' && typeof $globalThis.vscode.process !== 'undefined') {\n    // Native environment (sandboxed)\n    nodeProcess = $globalThis.vscode.process;\n}\nelse if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {\n    // Native environment (non-sandboxed)\n    nodeProcess = process;\n}\nconst isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';\nconst isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';\n// Native environment\nif (typeof nodeProcess === 'object') {\n    _isWindows = (nodeProcess.platform === 'win32');\n    _isMacintosh = (nodeProcess.platform === 'darwin');\n    _isLinux = (nodeProcess.platform === 'linux');\n    _isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\n    _isElectron = isElectronProcess;\n    _isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'];\n    _locale = exports.LANGUAGE_DEFAULT;\n    _language = exports.LANGUAGE_DEFAULT;\n    const rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\n    if (rawNlsConfig) {\n        try {\n            const nlsConfig = JSON.parse(rawNlsConfig);\n            _locale = nlsConfig.userLocale;\n            _platformLocale = nlsConfig.osLocale;\n            _language = nlsConfig.resolvedLanguage || exports.LANGUAGE_DEFAULT;\n            _translationsConfigFile = nlsConfig.languagePack?.translationsConfigFile;\n        }\n        catch (e) {\n        }\n    }\n    _isNative = true;\n}\n// Web environment\nelse if (typeof navigator === 'object' && !isElectronRenderer) {\n    _userAgent = navigator.userAgent;\n    _isWindows = _userAgent.indexOf('Windows') >= 0;\n    _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\n    _isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\n    _isLinux = _userAgent.indexOf('Linux') >= 0;\n    _isMobile = _userAgent?.indexOf('Mobi') >= 0;\n    _isWeb = true;\n    // VSCODE_GLOBALS: NLS\n    _language = globalThis._VSCODE_NLS_LANGUAGE || exports.LANGUAGE_DEFAULT;\n    _locale = navigator.language.toLowerCase();\n    _platformLocale = _locale;\n}\n// Unknown environment\nelse {\n    console.error('Unable to resolve platform.');\n}\nvar Platform;\n(function (Platform) {\n    Platform[Platform[\"Web\"] = 0] = \"Web\";\n    Platform[Platform[\"Mac\"] = 1] = \"Mac\";\n    Platform[Platform[\"Linux\"] = 2] = \"Linux\";\n    Platform[Platform[\"Windows\"] = 3] = \"Windows\";\n})(Platform || (exports.Platform = Platform = {}));\nfunction PlatformToString(platform) {\n    switch (platform) {\n        case Platform.Web: return 'Web';\n        case Platform.Mac: return 'Mac';\n        case Platform.Linux: return 'Linux';\n        case Platform.Windows: return 'Windows';\n    }\n}\nlet _platform = Platform.Web;\nif (_isMacintosh) {\n    _platform = Platform.Mac;\n}\nelse if (_isWindows) {\n    _platform = Platform.Windows;\n}\nelse if (_isLinux) {\n    _platform = Platform.Linux;\n}\nexports.isWindows = _isWindows;\nexports.isMacintosh = _isMacintosh;\nexports.isLinux = _isLinux;\nexports.isLinuxSnap = _isLinuxSnap;\nexports.isNative = _isNative;\nexports.isElectron = _isElectron;\nexports.isWeb = _isWeb;\nexports.isWebWorker = (_isWeb && typeof $globalThis.importScripts === 'function');\nexports.webWorkerOrigin = exports.isWebWorker ? $globalThis.origin : undefined;\nexports.isIOS = _isIOS;\nexports.isMobile = _isMobile;\n/**\n * Whether we run inside a CI environment, such as\n * GH actions or Azure Pipelines.\n */\nexports.isCI = _isCI;\nexports.platform = _platform;\nexports.userAgent = _userAgent;\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese or de for German)\n */\nexports.language = _language;\nvar Language;\n(function (Language) {\n    function value() {\n        return exports.language;\n    }\n    Language.value = value;\n    function isDefaultVariant() {\n        if (exports.language.length === 2) {\n            return exports.language === 'en';\n        }\n        else if (exports.language.length >= 3) {\n            return exports.language[0] === 'e' && exports.language[1] === 'n' && exports.language[2] === '-';\n        }\n        else {\n            return false;\n        }\n    }\n    Language.isDefaultVariant = isDefaultVariant;\n    function isDefault() {\n        return exports.language === 'en';\n    }\n    Language.isDefault = isDefault;\n})(Language || (exports.Language = Language = {}));\n/**\n * Desktop: The OS locale or the locale specified by --locale or `argv.json`.\n * Web: matches `platformLocale`.\n *\n * The UI is not necessarily shown in the provided locale.\n */\nexports.locale = _locale;\n/**\n * This will always be set to the OS/browser's locale regardless of\n * what was specified otherwise. The format of the string is all\n * lower case (e.g. zh-tw for Traditional Chinese). The UI is not\n * necessarily shown in the provided locale.\n */\nexports.platformLocale = _platformLocale;\n/**\n * The translations that are available through language packs.\n */\nexports.translationsConfigFile = _translationsConfigFile;\nexports.setTimeout0IsFaster = (typeof $globalThis.postMessage === 'function' && !$globalThis.importScripts);\n/**\n * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.\n *\n * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay\n * that browsers set when the nesting level is > 5.\n */\nexports.setTimeout0 = (() => {\n    if (exports.setTimeout0IsFaster) {\n        const pending = [];\n        $globalThis.addEventListener('message', (e) => {\n            if (e.data && e.data.vscodeScheduleAsyncWork) {\n                for (let i = 0, len = pending.length; i < len; i++) {\n                    const candidate = pending[i];\n                    if (candidate.id === e.data.vscodeScheduleAsyncWork) {\n                        pending.splice(i, 1);\n                        candidate.callback();\n                        return;\n                    }\n                }\n            }\n        });\n        let lastId = 0;\n        return (callback) => {\n            const myId = ++lastId;\n            pending.push({\n                id: myId,\n                callback: callback\n            });\n            $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, '*');\n        };\n    }\n    return (callback) => setTimeout(callback);\n})();\nvar OperatingSystem;\n(function (OperatingSystem) {\n    OperatingSystem[OperatingSystem[\"Windows\"] = 1] = \"Windows\";\n    OperatingSystem[OperatingSystem[\"Macintosh\"] = 2] = \"Macintosh\";\n    OperatingSystem[OperatingSystem[\"Linux\"] = 3] = \"Linux\";\n})(OperatingSystem || (exports.OperatingSystem = OperatingSystem = {}));\nexports.OS = (_isMacintosh || _isIOS ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\nlet _isLittleEndian = true;\nlet _isLittleEndianComputed = false;\nfunction isLittleEndian() {\n    if (!_isLittleEndianComputed) {\n        _isLittleEndianComputed = true;\n        const test = new Uint8Array(2);\n        test[0] = 1;\n        test[1] = 2;\n        const view = new Uint16Array(test.buffer);\n        _isLittleEndian = (view[0] === (2 << 8) + 1);\n    }\n    return _isLittleEndian;\n}\nexports.isChrome = !!(exports.userAgent && exports.userAgent.indexOf('Chrome') >= 0);\nexports.isFirefox = !!(exports.userAgent && exports.userAgent.indexOf('Firefox') >= 0);\nexports.isSafari = !!(!exports.isChrome && (exports.userAgent && exports.userAgent.indexOf('Safari') >= 0));\nexports.isEdge = !!(exports.userAgent && exports.userAgent.indexOf('Edg/') >= 0);\nexports.isAndroid = !!(exports.userAgent && exports.userAgent.indexOf('Android') >= 0);\nfunction isBigSurOrNewer(osVersion) {\n    return parseFloat(osVersion) >= 20;\n}\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StopWatch = void 0;\nconst hasPerformanceNow = (globalThis.performance && typeof globalThis.performance.now === 'function');\nclass StopWatch {\n    static create(highResolution) {\n        return new StopWatch(highResolution);\n    }\n    constructor(highResolution) {\n        this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);\n        this._startTime = this._now();\n        this._stopTime = -1;\n    }\n    stop() {\n        this._stopTime = this._now();\n    }\n    reset() {\n        this._startTime = this._now();\n        this._stopTime = -1;\n    }\n    elapsed() {\n        if (this._stopTime !== -1) {\n            return this._stopTime - this._startTime;\n        }\n        return this._now() - this._startTime;\n    }\n}\nexports.StopWatch = StopWatch;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MicrotaskDelay = void 0;\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexports.MicrotaskDelay = Symbol('MicrotaskDelay');\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport type { Terminal, IDisposable, ITerminalAddon } from '@xterm/xterm';\nimport type { SearchAddon as ISearchApi, ISearchOptions, ISearchAddonOptions, ISearchResultChangeEvent } from '@xterm/addon-search';\nimport { Event } from 'vs/base/common/event';\nimport { Disposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { disposableTimeout } from 'vs/base/common/async';\nimport { SearchLineCache } from './SearchLineCache';\nimport { SearchState } from './SearchState';\nimport { SearchEngine, type ISearchResult } from './SearchEngine';\nimport { DecorationManager } from './DecorationManager';\nimport { SearchResultTracker } from './SearchResultTracker';\n\ninterface IInternalSearchOptions {\n  noScroll: boolean;\n}\n\n/**\n * Configuration constants for the search addon functionality.\n */\nconst enum Constants {\n  /**\n   * Default maximum number of search results to highlight simultaneously. This limit prevents\n   * performance degradation when searching for very common terms that would result in excessive\n   * highlighting decorations.\n   */\n  DEFAULT_HIGHLIGHT_LIMIT = 1000\n}\n\nexport class SearchAddon extends Disposable implements ITerminalAddon, ISearchApi {\n  private _terminal: Terminal | undefined;\n  private _highlightLimit: number;\n  private _highlightTimeout = this._register(new MutableDisposable<IDisposable>());\n  private _lineCache = this._register(new MutableDisposable<SearchLineCache>());\n\n  // Component instances\n  private _state = new SearchState();\n  private _engine: SearchEngine | undefined;\n  private _decorationManager: DecorationManager | undefined;\n  private _resultTracker = this._register(new SearchResultTracker());\n\n  public get onDidChangeResults(): Event<ISearchResultChangeEvent> {\n    return this._resultTracker.onDidChangeResults;\n  }\n\n  constructor(options?: Partial<ISearchAddonOptions>) {\n    super();\n\n    this._highlightLimit = options?.highlightLimit ?? Constants.DEFAULT_HIGHLIGHT_LIMIT;\n  }\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n    this._lineCache.value = new SearchLineCache(terminal);\n    this._engine = new SearchEngine(terminal, this._lineCache.value);\n    this._decorationManager = new DecorationManager(terminal);\n    this._register(this._terminal.onWriteParsed(() => this._updateMatches()));\n    this._register(this._terminal.onResize(() => this._updateMatches()));\n    this._register(toDisposable(() => this.clearDecorations()));\n  }\n\n  private _updateMatches(): void {\n    this._highlightTimeout.clear();\n    if (this._state.cachedSearchTerm && this._state.lastSearchOptions?.decorations) {\n      this._highlightTimeout.value = disposableTimeout(() => {\n        const term = this._state.cachedSearchTerm;\n        this._state.clearCachedTerm();\n        this.findPrevious(term!, { ...this._state.lastSearchOptions, incremental: true }, { noScroll: true });\n      }, 200);\n    }\n  }\n\n  public clearDecorations(retainCachedSearchTerm?: boolean): void {\n    this._resultTracker.clearSelectedDecoration();\n    this._decorationManager?.clearHighlightDecorations();\n    this._resultTracker.clearResults();\n    if (!retainCachedSearchTerm) {\n      this._state.clearCachedTerm();\n    }\n  }\n\n  public clearActiveDecoration(): void {\n    this._resultTracker.clearSelectedDecoration();\n  }\n\n  /**\n   * Find the next instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @returns Whether a result was found.\n   */\n  public findNext(term: string, searchOptions?: ISearchOptions, internalSearchOptions?: IInternalSearchOptions): boolean {\n    if (!this._terminal || !this._engine) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    this._state.lastSearchOptions = searchOptions;\n\n    if (this._state.shouldUpdateHighlighting(term, searchOptions)) {\n      this._highlightAllMatches(term, searchOptions!);\n    }\n\n    const found = this._findNextAndSelect(term, searchOptions, internalSearchOptions);\n    this._fireResults(searchOptions);\n    this._state.cachedSearchTerm = term;\n\n    return found;\n  }\n\n  private _highlightAllMatches(term: string, searchOptions: ISearchOptions): void {\n    if (!this._terminal || !this._engine || !this._decorationManager) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    if (!this._state.isValidSearchTerm(term)) {\n      this.clearDecorations();\n      return;\n    }\n\n    // new search, clear out the old decorations\n    this.clearDecorations(true);\n\n    const results: ISearchResult[] = [];\n    let prevResult: ISearchResult | undefined = undefined;\n    let result = this._engine.find(term, 0, 0, searchOptions);\n\n    while (result && (prevResult?.row !== result.row || prevResult?.col !== result.col)) {\n      if (results.length >= this._highlightLimit) {\n        break;\n      }\n      prevResult = result;\n      results.push(prevResult);\n      result = this._engine.find(\n        term,\n        prevResult.col + prevResult.term.length >= this._terminal.cols ? prevResult.row + 1 : prevResult.row,\n        prevResult.col + prevResult.term.length >= this._terminal.cols ? 0 : prevResult.col + 1,\n        searchOptions\n      );\n    }\n\n    this._resultTracker.updateResults(results, this._highlightLimit);\n    if (searchOptions.decorations) {\n      this._decorationManager.createHighlightDecorations(results, searchOptions.decorations);\n    }\n  }\n\n  private _findNextAndSelect(term: string, searchOptions?: ISearchOptions, internalSearchOptions?: IInternalSearchOptions): boolean {\n    if (!this._terminal || !this._engine) {\n      return false;\n    }\n    if (!this._state.isValidSearchTerm(term)) {\n      this._terminal.clearSelection();\n      this.clearDecorations();\n      return false;\n    }\n\n    const result = this._engine.findNextWithSelection(term, searchOptions, this._state.cachedSearchTerm);\n    return this._selectResult(result, searchOptions?.decorations, internalSearchOptions?.noScroll);\n  }\n\n  /**\n   * Find the previous instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @returns Whether a result was found.\n   */\n  public findPrevious(term: string, searchOptions?: ISearchOptions, internalSearchOptions?: IInternalSearchOptions): boolean {\n    if (!this._terminal || !this._engine) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    this._state.lastSearchOptions = searchOptions;\n\n    if (this._state.shouldUpdateHighlighting(term, searchOptions)) {\n      this._highlightAllMatches(term, searchOptions!);\n    }\n\n    const found = this._findPreviousAndSelect(term, searchOptions, internalSearchOptions);\n    this._fireResults(searchOptions);\n    this._state.cachedSearchTerm = term;\n\n    return found;\n  }\n\n  private _fireResults(searchOptions?: ISearchOptions): void {\n    this._resultTracker.fireResultsChanged(!!searchOptions?.decorations);\n  }\n\n  private _findPreviousAndSelect(term: string, searchOptions?: ISearchOptions, internalSearchOptions?: IInternalSearchOptions): boolean {\n    if (!this._terminal || !this._engine) {\n      return false;\n    }\n    if (!this._state.isValidSearchTerm(term)) {\n      this._terminal.clearSelection();\n      this.clearDecorations();\n      return false;\n    }\n\n    const result = this._engine.findPreviousWithSelection(term, searchOptions, this._state.cachedSearchTerm);\n    return this._selectResult(result, searchOptions?.decorations, internalSearchOptions?.noScroll);\n  }\n\n  /**\n   * Selects and scrolls to a result.\n   * @param result The result to select.\n   * @returns Whether a result was selected.\n   */\n  private _selectResult(result: ISearchResult | undefined, options?: any, noScroll?: boolean): boolean {\n    if (!this._terminal || !this._decorationManager) {\n      return false;\n    }\n\n    this._resultTracker.clearSelectedDecoration();\n    if (!result) {\n      this._terminal.clearSelection();\n      return false;\n    }\n\n    this._terminal.select(result.col, result.row, result.size);\n    if (options) {\n      const activeDecoration = this._decorationManager.createActiveDecoration(result, options);\n      if (activeDecoration) {\n        this._resultTracker.selectedDecoration = activeDecoration;\n      }\n    }\n\n    if (!noScroll) {\n      // If it is not in the viewport then we scroll else it just gets selected\n      if (result.row >= (this._terminal.buffer.active.viewportY + this._terminal.rows) || result.row < this._terminal.buffer.active.viewportY) {\n        let scroll = result.row - this._terminal.buffer.active.viewportY;\n        scroll -= Math.floor(this._terminal.rows / 2);\n        this._terminal.scrollLines(scroll);\n      }\n    }\n    return true;\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","globalThis","DecorationManager","Disposable","constructor","_terminal","super","_highlightDecorations","_highlightedLines","Set","this","_register","toDisposable","clearHighlightDecorations","createHighlightDecorations","results","options","match","decorations","_createResultDecorations","decoration","_storeDecoration","createActiveDecoration","result","dispose","clear","add","marker","line","push","_applyStyles","element","borderColor","isActiveResult","classList","contains","style","outline","decorationRanges","currentCol","col","remainingSize","size","markerOffset","buffer","active","baseY","cursorY","row","amountThisRow","Math","min","cols","range","registerMarker","registerDecoration","x","width","backgroundColor","activeMatchBackground","matchBackground","overviewRulerOptions","has","undefined","color","activeMatchColorOverviewRuler","matchOverviewRuler","position","disposables","onRender","e","activeMatchBorder","matchBorder","onDispose","length","_lineCache","find","term","startRow","startCol","searchOptions","clearSelection","Error","initLinesCache","searchPosition","_findInLine","y","rows","findNextWithSelection","cachedSearchTerm","prevSelectedPos","getSelectionPosition","end","start","findPreviousWithSelection","isReverseSearch","max","_isWholeWord","searchIndex","includes","firstLine","getLine","isWrapped","cache","getLineFromCache","translateBufferLineToStringWithWrap","setLineInCache","stringLine","offsets","offset","_bufferColsToStringOffset","searchTerm","searchStringLine","regex","caseSensitive","toLowerCase","resultIndex","searchRegex","RegExp","foundTerm","exec","slice","lastIndex","lastIndexOf","indexOf","wholeWord","startRowOffset","endRowOffset","startColOffset","endColOffset","startColIndex","_stringLengthToBufferSize","i","cell","getCell","char","getChars","nextCell","getWidth","lineIndex","getCode","SearchLineCache","_linesCacheTimeout","MutableDisposable","_linesCacheDisposables","_destroyLinesCache","_linesCache","Array","value","combinedDisposable","onLineFeed","onCursorMove","onResize","disposableTimeout","entry","trimRight","strings","lineOffsets","nextLine","lineWrapsToNext","string","translateToString","lastCell","join","SearchResultTracker","_searchResults","_onDidChangeResults","Emitter","onDidChangeResults","event","searchResults","selectedDecoration","_selectedDecoration","updateResults","maxResults","clearResults","clearSelectedDecoration","findResultIndex","fireResultsChanged","hasDecorations","fire","resultCount","reset","_cachedSearchTerm","lastSearchOptions","_lastSearchOptions","isValidSearchTerm","didOptionsChange","newOptions","shouldUpdateHighlighting","clearCachedTerm","Object","defineProperty","Permutation","CallbackIterable","ArrayQueue","booleanComparator","numberComparator","CompareResult","tail","array","n","tail2","arr","equals","one","other","itemEquals","a","b","len","removeFastWithoutKeepingOrder","index","last","pop","binarySearch","key","comparator","binarySearch2","quickSelect","nth","data","compare","TypeError","pivotValue","floor","random","lower","higher","pivots","val","groupBy","currentGroup","sort","groupAdjacentBy","items","shouldBeGrouped","item","forEachAdjacent","f","forEachWithNeighbors","sortedDiff","delta","before","after","splices","removed","added","splice","deleteCount","toInsert","top","topStep","topAsync","batch","token","Promise","resolve","reject","o","m","setTimeout","isCancellationRequested","errors_1","CancellationError","then","coalesce","filter","coalesceInPlace","to","move","from","isFalsyOrEmpty","obj","isArray","isNonEmptyArray","distinct","keyFn","seen","uniqueFilter","firstOrDefault","notFoundValue","lastOrDefault","commonPrefixLength","arg","indexer","mapper","reduce","r","t","create","insert","remove","arrayInsert","target","insertIndex","insertArr","concat","shuffle","_seed","rand","seed","sin","j","temp","pushToStart","unshift","pushToEnd","pushMany","mapArrayOrNot","fn","map","asArray","getRandomElement","insertInto","newItems","getActualStartIndex","compareBy","selector","tieBreakComparators","comparators","item1","item2","isNeitherLessOrGreaterThan","neitherLessOrGreaterThan","reverseOrder","arraysFind_1","compareToKey","low","high","mid","comp","pushSplice","latest","beforeIdx","afterIdx","beforeElement","afterElement","findFirstIdxMonotonousOrArrLen","startIdx","originalLength","newItemsLength","isLessThan","isLessThanOrEqual","isGreaterThan","greaterThan","lessThan","firstIdx","lastIdx","takeWhile","predicate","takeFromEndWhile","endIdx","peek","peekLast","dequeue","removeLast","takeCount","count","empty","_callback","iterate","forEach","handler","toArray","cb","mapFn","some","findFirst","findLast","findLastMaxBy","first","_indexMap","createSortPermutation","compareFn","sortIndices","keys","index1","index2","apply","_","inverse","inverseIndexMap","findLastIdx","fromIndex","findLastIdxMonotonous","endIdxEx","k","MonotonousArray","idx","findLastMonotonous","findFirstMonotonous","findFirstIdxMonotonous","findFirstMax","findLastMax","findFirstMin","findMaxIdx","maxIdx","mapFindFirst","mapped","assertInvariants","_array","_findLastMonotonousLastIdx","_prevFindLastPredicate","AsyncIterableSource","CancelableAsyncIterableObject","AsyncIterableObject","LazyStatefulPromise","StatefulPromise","Promises","DeferredPromise","IntervalCounter","TaskSequentializer","GlobalIdleValue","AbstractIdleValue","_runWhenIdle","runWhenGlobalIdle","ThrottledWorker","RunOnceWorker","ProcessTimeRunOnceScheduler","RunOnceScheduler","IntervalTimer","TimeoutTimer","LimitedQueue","Queue","Limiter","AutoOpenBarrier","Barrier","ThrottledDelayer","Delayer","SequencerByKey","Sequencer","Throttler","isThenable","createCancelablePromise","raceCancellation","promise","defaultValue","ref","onCancellationRequested","finally","raceCancellationError","raceCancellablePromises","async","cancellablePromises","resolvedPromiseIndex","promises","race","cancellablePromise","cancel","raceTimeout","timeout","onTimeout","promiseResolve","timer","clearTimeout","asPromise","callback","promiseWithResolvers","store","disposable","lifecycle_1","deleteAndLeak","sequence","promiseFactories","thenHandler","shouldStop","loop","firstParallel","promiseList","todo","finish","catch","err","retry","task","delay","retries","lastError","error","createCancelableAsyncIterable","source","cancellation_1","CancellationTokenSource","innerIterable","emitter","subscription","emitOne","event_1","platform_1","symbols_1","lazy_1","thenable","onfinally","res","rej","isDisposed","activePromise","queuedPromise","queuedPromiseFactory","queue","promiseFactory","onComplete","current","promiseTask","promiseMap","Map","newPromise","get","delete","set","defaultDelay","deferred","completionPromise","doResolve","doReject","trigger","cancelTimeout","MicrotaskDelay","scheduled","queueMicrotask","isTriggered","microtaskDeferred","handle","timeoutDeferred","delayer","throttler","_isOpen","_promise","c","_completePromise","isOpen","open","wait","millis","autoOpenTimeMs","_timeout","maxDegreeOfParalellism","_size","_isDisposed","outstandingPromises","runningPromises","_onDrained","whenIdle","Event","toPromise","onDrained","consume","iLimitedTask","shift","consumed","sequentializer","tasks","isRunning","run","runner","_token","setIfNotSet","cancelAndSet","BugIndicatingError","interval","context","setInterval","clearInterval","timeoutToken","timeoutHandler","bind","isScheduled","schedule","flush","doRun","console","warn","counter","intervalToken","intervalHandler","onInterval","ceil","units","work","unit","pendingWork","disposed","pending","maxBufferedWork","maxWorkChunkSize","doWork","throttleDelay","requestIdleCallback","cancelIdleCallback","_targetWindow","setTimeout0","Date","now","deadline","didTimeout","timeRemaining","freeze","targetWindow","executor","_didRun","_executor","_value","_error","_handle","isInitialized","taskId","_running","running","cancelRunning","onCancel","doneRunning","runQueued","_queued","queued","promiseReject","hasQueued","DeferredOutcome","AsyncIterableSourceState","nowFn","lastIncrementTime","increment","isRejected","outcome","Rejected","isResolved","Resolved","isSettled","p","completeCallback","errorCallback","complete","settled","firstError","all","withAsyncBody","bodyFn","_isResolved","requireValue","_compute","Lazy","getPromise","currentValue","rawValue","fromArray","writer","emitMany","fromPromise","fromPromises","merge","iterables","iterable","EMPTY","onReturn","_state","Initial","_results","_onReturn","_onStateChanged","Symbol","asyncIterator","next","DoneError","done","DoneOK","return","filterFn","values","_source","earlyError","earlyItems","_deferred","_asyncIterable","_errorFn","_emitFn","asyncIterable","CancellationToken","cancelOnDispose","shortcutEvent","isCancellationToken","thing","None","Cancelled","MutableToken","_isCancelled","_emitter","parent","_parentListener","_a","SetWithKey","groupFn","diffSets","diffMaps","intersection","setA","setB","elem","toStringTag","toKey","_map","entries","callbackfn","thisArg","call","iterator","ErrorNoTelemetry","ExpectedError","NotSupportedError","NotImplementedError","ReadonlyError","errorHandler","ErrorHandler","setUnexpectedErrorHandler","newUnexpectedErrorHandler","isSigPipeError","cast","code","syscall","toUpperCase","onUnexpectedError","isCancellationError","onUnexpectedExternalError","transformErrorForSerialization","name","message","$isError","stack","stacktrace","noTelemetry","isErrorNoTelemetry","transformErrorFromSerialization","canceled","canceledName","illegalArgument","illegalState","getErrorMessage","split","String","listeners","unexpectedErrorHandler","addListener","listener","_removeListener","emit","getUnexpectedErrorHandler","arguments","isExpected","msg","fromError","setPrototypeOf","prototype","ValueWithChangeEvent","Relay","EventBufferer","DynamicListEventMultiplexer","EventMultiplexer","MicrotaskEmitter","DebounceEmitter","PauseableEmitter","AsyncEmitter","createEventDeliveryQueue","ListenerRefusalError","ListenerLeakError","EventProfiling","setGlobalLeakWarningThreshold","oldValue","_globalLeakWarningThreshold","functional_1","linkedList_1","stopwatch_1","once","thisArgs","didFire","snapshot","onWillAddFirstListener","onDidRemoveLastListener","debounce","leading","flushOnListenerRemove","leakWarningThreshold","output","doFire","numDebouncedCalls","cur","_output","onWillRemoveListener","defer","each","signal","any","events","d","initial","accumulate","latch","firstCall","shouldEmit","isT","flushAfterTimeout","_buffer","onDidAddFirstListener","chain","sythensize","cs","ChainableSynthesis","evaluate","HaltChainable","steps","v","step","fromNodeEventEmitter","eventName","id","args","on","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","forward","runAndSubscribe","EmitterObserver","_observable","_counter","_hasChanged","addObserver","removeObserver","beginUpdate","handlePossibleChange","handleChange","_change","endUpdate","reportChanges","fromObservable","obs","fromObservableLight","observable","didChange","observer","DisposableStore","_idPool","listenerCount","invocationCount","elapsedOverall","durations","_stopWatch","StopWatch","stop","elapsed","LeakageMonitor","_errorHandler","threshold","toString","padStart","_warnCountdown","_stacks","check","topStack","topCount","getMostFrequentStack","Stacktrace","print","UniqueContainer","_options","_leakageMon","onListenerError","_perfMon","_profName","_deliveryQueue","deliveryQueue","_disposed","_listeners","_event","tuple","contained","removeMonitor","EventDeliveryQueuePrivate","log","JSON","stringify","adjustDeliveryQueue","_deliver","_deliverQueue","dq","enqueue","hasListeners","fireAsync","promiseJoin","_asyncDeliveryQueue","LinkedList","l","forEachListener","thenables","waitUntil","isFrozen","allSettled","status","reason","isPaused","_isPaused","_eventQueue","_mergeFn","pause","resume","_delay","_queuedEvents","onFirstListenerAdd","onLastListenerRemove","hook","createSingleCallFunction","unhook","onAddItem","onRemoveItem","getEvent","_store","multiplexer","itemListeners","DisposableMap","addItem","instance","deleteAndDispose","wrapEvent","buffers","reduceData","reducedResult","bufferEvents","listening","inputEvent","inputEventListener","input","ConstValueWithChangeEvent","_onDidChange","onDidChange","fnDidRunCallback","_this","didCall","Iterable","is","_empty","single","wrap","iterableOrElement","reverse","isEmpty","flatMap","reducer","initialValue","atMost","Number","POSITIVE_INFINITY","asyncToArray","hasValue","ImmortalReference","AsyncReferenceCollection","ReferenceCollection","SafeDisposable","RefCountedDisposable","MandatoryMutableDisposable","DisposableTracker","setDisposableTracker","tracker","disposableTracker","trackDisposable","markAsDisposed","markAsSingleton","singleton","isDisposable","disposeIfDisposable","children","child","setParent","setParentOfDisposables","disposeOnReturn","arrays_1","collections_1","map_1","iterator_1","livingDisposables","getDisposableData","isSingleton","getRootParent","cacheValue","getTrackedDisposables","rootParentCache","computeLeakingDisposables","maxReported","preComputedLeaks","uncoveredLeakingObjs","leakingObjects","info","leakingObjsSet","getStackTracePath","leaking","lines","trim","replace","linesToRemove","regexp","removePrefix","stackTraceStarts","SetMap","stackTracePath","stackTraceFormattedLines","prevStarts","continuations","cont","leaks","details","setParentOfDisposable","errors","AggregateError","self","DISABLE_DISPOSED_WARNING","_toDispose","clearAndLeak","_disposable","acquire","release","unset","isset","references","reference","object","createReferencedObject","destroyReferencedObject","referenceCollection","clearAndDisposeAll","skipDisposeOnOverwrite","Node","Undefined","prev","_first","_last","node","_insert","atTheEnd","newNode","oldLast","oldFirst","didRemove","_remove","anchor","Touch","BidirectionalMap","CounterSet","getOrSet","mapToString","setToString","mapsStrictEqualIgnoreOrder","_m1","_m2","getKey","isAndroid","isEdge","isSafari","isFirefox","isChrome","OS","OperatingSystem","setTimeout0IsFaster","translationsConfigFile","platformLocale","locale","Language","language","userAgent","platform","isCI","isMobile","isIOS","webWorkerOrigin","isWebWorker","isWeb","isElectron","isNative","isLinuxSnap","isLinux","isMacintosh","isWindows","Platform","LANGUAGE_DEFAULT","PlatformToString","Web","Mac","Linux","Windows","isLittleEndian","_isLittleEndianComputed","test","Uint8Array","view","Uint16Array","_isLittleEndian","isBigSurOrNewer","osVersion","parseFloat","_locale","_translationsConfigFile","_userAgent","_isWindows","_isMacintosh","_isLinux","_isLinuxSnap","_isNative","_isWeb","_isElectron","_isIOS","_isCI","_isMobile","_language","_platformLocale","$globalThis","nodeProcess","vscode","process","versions","isElectronProcess","electron","isElectronRenderer","type","env","rawNlsConfig","nlsConfig","parse","userLocale","osLocale","resolvedLanguage","languagePack","navigator","maxTouchPoints","_VSCODE_NLS_LANGUAGE","_platform","importScripts","origin","isDefaultVariant","isDefault","postMessage","vscodeScheduleAsyncWork","candidate","lastId","myId","Macintosh","hasPerformanceNow","performance","highResolution","_now","_startTime","_stopTime","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","SearchAddon","_resultTracker","_highlightTimeout","SearchState","_highlightLimit","highlightLimit","activate","terminal","_engine","SearchEngine","_decorationManager","onWriteParsed","_updateMatches","clearDecorations","findPrevious","incremental","noScroll","retainCachedSearchTerm","clearActiveDecoration","findNext","internalSearchOptions","_highlightAllMatches","found","_findNextAndSelect","_fireResults","prevResult","_selectResult","_findPreviousAndSelect","select","activeDecoration","viewportY","scroll","scrollLines"],"sourceRoot":""}